<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZeTiiCannotStop</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-10-04T10:07:16.037Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>ZeTii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>3Blue1Brown_线代本质第八章：叉积的标准介绍</title>
    <link href="http://example.com/2022/10/03/math_Essense_of_Linear_Algebra_P08/"/>
    <id>http://example.com/2022/10/03/math_Essense_of_Linear_Algebra_P08/</id>
    <published>2022-10-03T09:15:35.000Z</published>
    <updated>2022-10-04T10:07:16.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3Blue1Brown-线代本质第八章：叉积的标准介绍"><a href="#3Blue1Brown-线代本质第八章：叉积的标准介绍" class="headerlink" title="3Blue1Brown_线代本质第八章：叉积的标准介绍"></a>3Blue1Brown_线代本质第八章：叉积的标准介绍</h1><ul><li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第八章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li><li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li><li>官方一共将此系列分为12节，所以我也会分开写。</li><li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li><li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li></ul><hr><blockquote><p>【注：此篇为第八章第一部分《叉积的标准介绍》和第二部分《以线性变换的眼光看叉积》的集合】</p></blockquote><hr><h2 id="✏️叉积（cross-product）："><a href="#✏️叉积（cross-product）：" class="headerlink" title="✏️叉积（cross product）："></a>✏️叉积（cross product）：</h2><h3 id="✍️基本理解（非严格意义上的叉乘）："><a href="#✍️基本理解（非严格意义上的叉乘）：" class="headerlink" title="✍️基本理解（非严格意义上的叉乘）："></a>✍️基本理解（非严格意义上的叉乘）：</h3><ul><li>从平面空间说起，加入有两个向量v和w，考虑他们所张成的平行四边形，v和w的叉积v X w 其实就是这个平行四边形的面积。</li><li>当然我们还要考虑定向问题；如果v在w的右侧，那么v叉乘w为正；并且值等于平行四边形的面积。如果v在w的左侧，那么v叉乘w为负。这就是说顺序会对叉积有影响。</li><li>如果你不计算w叉乘v，而是交换二者位置计算，那么叉积就是之前计算结果的相反数。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%8F%89%E7%A7%AF%E5%B9%B3%E9%9D%A2%E7%A9%BA%E9%97%B4.png" alt="叉积平面空间"></li><li>记住顺序的方法是：当你按顺序求两个基向量的叉积，即i帽叉乘j帽，结果应该是正的。基向量的顺序就是定向的基础，因为i帽在j帽的右侧。同理运用到v和w上一样如此，v在w右侧，结果为正；反之为负。</li><li>举例如下图，如果v的坐标为（-3，1），w的坐标为（2，1），以他们的坐标为列构成的行列式为（（-3）*1—） - （2 * 1），也就是-5。很显然，他们构成的平行四边形的面积为5；但v在w左侧，所以行列式结果为-5。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%AC%AC%E5%85%AB%E7%AB%A0%E7%A4%BA%E4%BE%8B%E4%B8%80.png" alt="第八章示例一"></li><li>如果两个向量垂直，或接近垂直，和他们指向接近时相比，此时的叉积更大。所以当两个向量接近通向时，他们的叉积更小。因为两条边接近垂直的时候，平行四边形的面积会更大。</li><li>如果放大其中的一个向量，比如将v放大为3倍，那么平行四边形的面积也放大三倍。这也就是说，3v叉乘w正好是v叉乘w的三倍。</li></ul><hr><h3 id="✍️严格意义上的叉乘："><a href="#✍️严格意义上的叉乘：" class="headerlink" title="✍️严格意义上的叉乘："></a>✍️严格意义上的叉乘：</h3><ul><li>通过两个三维向量，生成一个新的三维向量。</li><li>我们还是要考虑这两个向量围成的平行四边形，而这个平行四边形的面积依然会发挥着重要的作用。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%8F%89%E7%A7%AF%E7%9A%84%E5%9F%BA%E7%A1%80.png" alt="叉积的基础"></li><li>但是此时，叉积的结果应当是一个向量，所以就不能单纯用它的面积这个数来理解。<strong>这个向量的长度是这个平行四边形的面积，而这个向量的方向与平行四边形所在的面垂直</strong>。</li></ul><h4 id="叉积的方向："><a href="#叉积的方向：" class="headerlink" title="叉积的方向："></a>叉积的方向：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%8F%B3%E6%89%8B%E5%AE%9A%E5%88%99.png" alt="右手定则"></p><ul><li>因为长度为这个平行四边形面积并垂直于给定面的向量一共有两个，且方向相反，这里就需要用<strong>右手定则</strong>：<strong>右手食指指向v的方向，中指指向w的方向，当你把大拇指竖起来的方向，他所指的方向就是叉积的方向。</strong></li></ul><h4 id="公式："><a href="#公式：" class="headerlink" title="公式："></a>公式：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%8F%89%E4%B9%98%E7%9A%84%E4%B8%89%E9%98%B6%E8%BF%90%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="叉乘的三阶运算公式"></p><ul><li>这样计算并非巧合。</li></ul><hr><h2 id="✏️以线性变换的眼光看叉积："><a href="#✏️以线性变换的眼光看叉积：" class="headerlink" title="✏️以线性变换的眼光看叉积："></a>✏️以线性变换的眼光看叉积：</h2><h3 id="✍️推理过程："><a href="#✍️推理过程：" class="headerlink" title="✍️推理过程："></a>✍️推理过程：</h3><ul><li>对偶性的思想在于：每当你看见一个多维空间到数轴的线性变换时，它都与那个空间中唯一一个向量对应，也就是说应用线性变换和与这个向量点乘等价。数值上说，这是因为这类线性变换可以用一个只有一行的矩阵描述，而它的每一列给出了变换后基向量的位置。将这个矩阵与某个向量v相乘，在计算上与将矩阵转置得到的向量和v点乘相同。</li><li>这里的收获在于，每当你看到一个从空间到数轴的线性变换，你都能找到一个向量，被称为这个变换的对偶向量。使得应用线性变换和对偶向量点乘等价。</li><li>叉积的运算给出了此过程一个鲜活的实例。</li></ul><h3 id="✍️关于叉积的证明计划："><a href="#✍️关于叉积的证明计划：" class="headerlink" title="✍️关于叉积的证明计划："></a>✍️关于叉积的证明计划：</h3><ol><li>根据v和w定义一个三维到一维的线性变换。</li><li>找到它的对偶向量。</li><li>这个对偶向量就会是v和w的叉积。</li></ol><ul><li>理解线性变换能够解释清楚叉积的计算过程和几何含义之间的关系。</li><li><strong>真正的三维向量的叉积接受两个向量并输出一个向量</strong>，它并不是接收三个向量并输出一个数。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BB%A5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9C%8B%E5%BE%85%E5%8F%89%E7%A7%AF.png" alt="以线性变换看待叉积"></li><li>如上图所示，将第一个向量u看作可变向量，比如（x，y，z），而v和w保持不变；那么我们就有一个从三维空间到数轴的函数了。你输入一个向量（x，y，z），然后通过矩阵的行列式得到一个数。这个向量的第一列是（x，y，z），其余的两列是常向量v和w的坐标。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BB%A5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9C%8B%E5%BE%85%E5%8F%89%E7%A7%AF_02.png" alt="以线性变换看待叉积_02"></li><li>这个函数的几何意义是，对于任一输入的向量（x，y，z），你都考虑由它和v与w确定的平行六面体得到它的体积，然后根据定向确定符号。</li></ul><h3 id="但是这个函数从哪里来，为什么会这么计算？"><a href="#但是这个函数从哪里来，为什么会这么计算？" class="headerlink" title="但是这个函数从哪里来，为什么会这么计算？"></a><strong>但是这个函数从哪里来，为什么会这么计算？</strong></h3><ul><li>这个函数一个至关重要的性质就是它是线性的，因此可以引入对偶性的特性。</li><li>因为它是线性的，我们就知道可以通过矩阵乘法来描述这个函数；具体的说，因为这个函数从三维空间到一维空间，就会存在一个1x3矩阵来代表这个变换。而对偶性的整体思路是从多维空间到一维空间的变换的特别之处在于你可以把这个矩阵立起来并且将整个变换看作与这个特定向量的点积。</li><li>如下图所示，我们要找的就是这个特殊的三维向量，现在称之为P，使得P与其他任一向量（x，y，z）的点积等于一个3x3矩阵的行列式，这个3x3矩阵的第一列为（x，y，z），其余两列分别为v和w的坐标。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BB%A5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9C%8B%E5%BE%85%E5%8F%89%E7%A7%AF_03.png" alt="以线性变换看待叉积_03"></li><li>P与向量（x，y，z）点乘给出的结果以及右侧行列式的计算结果如下图所示：<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BB%A5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9C%8B%E5%BE%85%E5%8F%89%E7%A7%AF_04.png" alt="以线性变换看待叉积_04"></li><li>这里某些常数涉及了v和w的坐标的特定组合。因此这些常数，也就是v和w的坐标的特定组合，就是我们寻找到向量P的坐标。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BB%A5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9C%8B%E5%BE%85%E5%8F%89%E7%A7%AF_05.png" alt="以线性变换看待叉积_05"></li><li>等号右侧的过程，对于哪些进行过叉积计算的人来说是很熟悉的。</li><li>像这样合并x，y和z前面的常数项，和把i帽，j帽和k帽放进矩阵第一列进行计算，然后合并个项前面的系数没有区别。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BB%A5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9C%8B%E5%BE%85%E5%8F%89%E7%A7%AF_06.png" alt="以线性变换看待叉积_06"></li><li>在矩阵中插入i帽，j帽和k帽在传递一个信号，告诉我们应该把这些系数理解成一个向量坐标。</li><li>因此，这一切都在说明，这个奇怪的运算过程可以看作是以下问题的答案：<ul><li>当你将向量p和某个向量（x，y，z）点乘时，所得的结果等于一个3x3矩阵的行列式，这个矩阵第一列为（x，y，z），其余两列为v和w的坐标。考虑什么样的向量p可以完成这一特殊性质。</li><li>也可以这样说：当年将向量p和某个向量（x，y，z）点乘时，所得结果等于一个由（x，y，z）个v与w确定的平行六面体的邮箱体积，什么样的向量p可以完成这一特殊性质？</li></ul></li><li>记住一点，向量p与其他向量的点积的几何解释是将其他向量投影到p上，然后将投影长度与p的长度相乘。</li><li>根据这点，平行六面体的体积可以这样考虑：首先获得由v和w确定的平行四边形的面积，乘以向量（x，y，z）在垂直于平行四边形方向上的分量。</li><li>换句话说，我们找到线性函数对于给定向量的作用，是将这个向量投影到垂直于v和w的直线上，然后将投影长度于v和w张成的平行四边形的面积相乘。这和垂直于v和w且长度为平行四边形面积的向量与（x，y，z）点乘是同一回事。</li><li>更重要的是，如果你选择了合适的向量方向，点积为正的情况就会与（x，y，z），v和w满足右手定则的情况相吻合。</li><li>这意味着我们找到了一个向量p，使得p与和某个向量（x，y，z）点乘时所得结果等于一个3x3矩阵的行列式；这个矩阵的三列分别为（x，y，z），v的坐标和w的坐标。</li><li>因此我们之前通过特殊符号技巧进行计算所得到的向量必然在几何上与这个向量对应。这激素叉积的计算过程与几何解释有关的根本原因。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BB%A5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9C%8B%E5%BE%85%E5%8F%89%E7%A7%AF_07.png" alt="以线性变换看待叉积_07"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3Blue1Brown-线代本质第八章：叉积的标准介绍&quot;&gt;&lt;a href=&quot;#3Blue1Brown-线代本质第八章：叉积的标准介绍&quot; class=&quot;headerlink&quot; title=&quot;3Blue1Brown_线代本质第八章：叉积的标准介绍&quot;&gt;&lt;/a&gt;3Blue</summary>
      
    
    
    
    <category term="-3Blue1Brown线性代数本质" scheme="http://example.com/categories/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%9C%AC%E8%B4%A8/"/>
    
    
    <category term="-学数学" scheme="http://example.com/tags/%E5%AD%A6%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>3Blue1Brown_线代本质第七章：点积与对偶性</title>
    <link href="http://example.com/2022/09/29/math_Essense_of_Linear_Algebra_P07/"/>
    <id>http://example.com/2022/09/29/math_Essense_of_Linear_Algebra_P07/</id>
    <published>2022-09-29T09:15:35.000Z</published>
    <updated>2022-09-30T12:48:37.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3Blue1Brown-线代本质第七章：点积与对偶性"><a href="#3Blue1Brown-线代本质第七章：点积与对偶性" class="headerlink" title="3Blue1Brown_线代本质第七章：点积与对偶性"></a>3Blue1Brown_线代本质第七章：点积与对偶性</h1><ul><li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第七章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li><li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li><li>官方一共将此系列分为12节，所以我也会分开写。</li><li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li><li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li></ul><hr><h2 id="✏️点积（dot-product）："><a href="#✏️点积（dot-product）：" class="headerlink" title="✏️点积（dot product）："></a>✏️点积（dot product）：</h2><h3 id="✍️点积的标准观点："><a href="#✍️点积的标准观点：" class="headerlink" title="✍️点积的标准观点："></a>✍️点积的标准观点：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%82%B9%E7%A7%AF%E7%9A%84%E6%A0%87%E5%87%86%E8%A7%82%E7%82%B9.png" alt="点积的标准观点"></p><ul><li><strong>如果有两个维数相同的向量，或是两个长度相同的数组，求它的点积，就是将相应的坐标配对，求出每一对坐标的乘积，然后结果相加。</strong></li></ul><hr><h3 id="✍️几何计算："><a href="#✍️几何计算：" class="headerlink" title="✍️几何计算："></a>✍️几何计算：</h3><ul><li>这个计算有一个优美的几何解释：<ul><li><strong>如果要求两个向量v和w的点积，想象向量w朝着过原点和向量v终点的直线上投影（这里指正交投影），将投影的长度与向量v的长度相乘，就得到了他们的点积，v点乘w。</strong> 所以当两个向量的指向大致相同时，他们的点积为正。（方向为正）</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%82%B9%E4%B9%98%E5%87%A0%E4%BD%95%E8%AE%A1%E7%AE%97.png" alt="点乘几何计算"></li><li><strong>除非w的投影与v的方向相反，这种情况下点积为负。</strong> （指向方向相反）</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E8%B4%9F%E6%95%B0%E6%83%85%E5%86%B5%E4%B8%8B%E7%82%B9%E4%B9%98%E5%87%A0%E4%BD%95%E8%AE%A1%E7%AE%97.png" alt="负数情况下点乘几何计算"></li><li><strong>当他们互相垂直的时候，意味着一个向量在另一个向量上的投影为零向量。</strong></li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E9%9B%B6%E5%90%91%E9%87%8F%E6%83%85%E5%86%B5%E4%B8%8B%E7%82%B9%E4%B9%98%E5%87%A0%E4%BD%95%E8%AE%A1%E7%AE%97.png" alt="零向量情况下点乘几何计算"></li></ul></li></ul><hr><h3 id="✍️点积与顺序无关："><a href="#✍️点积与顺序无关：" class="headerlink" title="✍️点积与顺序无关："></a>✍️点积与顺序无关：</h3><ul><li><strong>你可以将v投影到w上，将v投影长度与w长度相乘；或者将w投影到v上，与将w投影长度与v相乘；他们的结果是一样的。</strong> </li><li>上面的话可以这么理解：<ul><li>可以先想想v与w长度相等，我们可以利用对称性，来知道他们的结果是相等的。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%82%B9%E7%A7%AF%E9%A1%BA%E5%BA%8F.png" alt="点积顺序"></li><li>如果我们此时将v放大两倍（现在成为2v），使得他们长度不同，那么现在对称性就被破坏了；但是我们可以这样理解2v和w的点积：<ul><li>如果认为w向v上投影，那么2v点乘w就应该恰好是v点乘w的两倍，现在就是（2v）·w&#x3D;2（v·w）；这是因为，将v放大为原来的两倍并不改变w的投影长度，但是被投影的向量长度变为原来的两倍。</li><li>另一方面，如果将v投影到w上，将v变为原来的两倍（2v），那么这次的是投影长度就变为原来的两倍（2v），但是被投影的向量w长度保持不变；所以总体效果任然是点积变为两倍。</li></ul></li><li>在两种理解方式下，缩放向量对点积结果的影响是相同的。</li></ul></li></ul><hr><h3 id="✍️对偶性（duality）："><a href="#✍️对偶性（duality）：" class="headerlink" title="✍️对偶性（duality）："></a>✍️对偶性（duality）：</h3><ul><li>有不少函数能够接收二维向量并输出一个数，同样是二维输入与一维输出，和一般函数相比，线性变换的要求更加严格。</li><li>如果你有一些列等距分布于一条直线上的点，然后应用变换，线性变换会保持这些点等距分布在输出空间中（也就是数轴上）；否则，如果这些点没有等距分布，那么这个变换就不是线性的。</li><li>这些线性变换完全由他对i帽和j帽的变换决定，但是这一次，这些基向量只落在一个数上。所以当我们将他们变换后的位置记录为矩阵的列时，矩阵的每列只是一个单独的数。</li><li>假设有一个线性变换，它将i帽和j帽分别变换到1和-2，要跟踪一个向量，比如向量（4，3），在变换后的去向；将这个向量分解为4乘以i帽加上3乘以j帽。由于线性性质，在变换后，这个向量的位置是4乘以变换后的i帽也就是1（4 * 1），加上3乘以变换后的j帽也就是-2（3 * -2）；那么他最终结果落在-2上。如下图所示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%AF%B9%E5%81%B6%E6%80%A7%E7%A4%BA%E4%BE%8B.png" alt="变换示例"></li><li>上图展示的就是1x2矩阵于向量相乘这一数值运算过程，感觉上就和两个向量的点积是一样的。那这个1x2矩阵正像是一个倾倒的向量。</li><li>1x2矩阵与二维向量之间有着微妙的联系；这种关系在于：将向量放倒从而得到与之相关的矩阵，获奖矩阵直立，从而得到与之相关向量。</li><li>因为我们现在只是从数值表达上来看待这个联系，所以向量和1x2矩阵来回之间转换看起来毫无意义。</li><li>几何上，将向量转换为数的线性变换和这个向量本身有着某种关系。</li></ul><hr><h4 id="【假设我们还不知道点积与投影有关：】"><a href="#【假设我们还不知道点积与投影有关：】" class="headerlink" title="【假设我们还不知道点积与投影有关：】"></a>【<strong>假设我们还不知道点积与投影有关：</strong>】</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/u%E5%B8%BD.png" alt="u帽"></p><ul><li>现在将数轴复制一份，然后保持0在原点；考虑一个二维向量，它的终点落在这条数轴上，我们现在管他叫“u帽”。</li><li>如果将二维向量直接投影到这条数轴上，实际上我们这样定义了一个从二维向量到数的函数；这个函数是线性的，它在直线上等距分布的点在投影到数轴上后依然等距分布。它输出的结果是数，而不是二维向量。</li><li>我们应该把它看作一个接收两个坐标并输出一个坐标的函数。</li><li>不过，u帽是二维空间中的一个向量，而它碰巧又落在这条数轴上，根据这个投影，我们定义了一个从二维向量到数的线性变换。所以我们就能找到描述这个变换的1x2矩阵。</li></ul><hr><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/u%E5%B8%BD%E4%B8%8Ei%E5%B8%BD%E7%9A%84%E6%8A%95%E5%BD%B1.png" alt="u帽与i帽的投影"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/u%E5%B8%BD%E4%B8%8Ei%E5%B8%BD%E7%9A%84%E6%8A%95%E5%BD%B1%E7%A4%BA%E6%84%8F.png" alt="u帽与i帽的投影示意"></p><ul><li>上图我们可以来看u帽和i帽之间的投影，因为u帽和i帽都是向量单位，那么将i帽向u帽所在的直线投影与u帽向x轴投影看上去完全对称。根据对称性，u帽向x轴的投影得到的数就是u帽的横坐标（ux）。</li><li>j帽的推理与x帽的一致，那么u帽的纵坐标就是（uy）。</li><li>所以描述投影变换的1x2矩阵的两列，就分别是u帽的两个坐标。</li><li>而空间中任意向量经过投影的变换结果，也就是投影矩阵与这个向量相乘；和这个向量与u帽的点积在计算上完全相同。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%9F%A9%E9%98%B5%E5%90%91%E9%87%8F%E7%9B%B8%E4%B9%98%E4%B8%8E%E7%82%B9%E7%A7%AF.png" alt="矩阵向量相乘与点积"></li><li>这就是为什么单位向量的点积可以解读为将向量投影到单位向量所在的直线上所得到的投影长度。</li></ul><hr><h4 id="非单位向量"><a href="#非单位向量" class="headerlink" title="非单位向量"></a>非单位向量</h4><ul><li>只要变换是线性的，那么新矩阵就可以看作基向量向着数轴投影并乘以新矩阵的变换倍数。这就素为什么向量与给定非向量的点积可以解读为：首先给向量投影，然后将投影的值于给定向量长度相乘。</li></ul><hr><h3 id="总结对偶性："><a href="#总结对偶性：" class="headerlink" title="总结对偶性："></a>总结对偶性：</h3><ul><li>你在任何时候看见一个线性变换，它的输出空间是一维数轴；无论它是如何定义的，空间中会存在唯一的向量v与之相关。就这一意义而言，应用变换和于向量v做点积是一样的。</li><li>它是数学中“<strong>对偶性</strong>”的一个实例。</li><li><strong>对偶性</strong>贯穿数学始终，在多个方面均有体现。粗略地说，它是指：<strong>两种数学事物之间自然而又出乎意料的对应关系</strong></li><li>犹如刚刚的实例，我们可以说一个向量的对偶是由它定义的线性变换。</li><li>一个多维空间到一个一维空间的线性变换的对偶是多维空间中的某个特定向量。</li><li>表面上看，点积是理解投影的有利几何工具，并且方便检验两个向量的指向是否相同（指向相同为正，指向相反为负，垂直为0）</li><li>两个向量点乘，就是将其中一个向量转化为线性变换。</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3Blue1Brown-线代本质第七章：点积与对偶性&quot;&gt;&lt;a href=&quot;#3Blue1Brown-线代本质第七章：点积与对偶性&quot; class=&quot;headerlink&quot; title=&quot;3Blue1Brown_线代本质第七章：点积与对偶性&quot;&gt;&lt;/a&gt;3Blue1Br</summary>
      
    
    
    
    <category term="-3Blue1Brown线性代数本质" scheme="http://example.com/categories/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%9C%AC%E8%B4%A8/"/>
    
    
    <category term="-学数学" scheme="http://example.com/tags/%E5%AD%A6%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>3Blue1Brown_线代本质第六章：逆矩阵，列空间与零空间</title>
    <link href="http://example.com/2022/09/27/math_Essense_of_Linear_Algebra_P06/"/>
    <id>http://example.com/2022/09/27/math_Essense_of_Linear_Algebra_P06/</id>
    <published>2022-09-27T14:15:35.000Z</published>
    <updated>2022-09-27T15:51:29.212Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>【<strong>注：本章笔记是第六章加附注二的笔记，也就是《逆矩阵，列空间与零空间》加《非方阵》。</strong>】</p></blockquote><h1 id="3Blue1Brown-线代本质第六章：逆矩阵，列空间与零空间"><a href="#3Blue1Brown-线代本质第六章：逆矩阵，列空间与零空间" class="headerlink" title="3Blue1Brown_线代本质第六章：逆矩阵，列空间与零空间"></a>3Blue1Brown_线代本质第六章：逆矩阵，列空间与零空间</h1><ul><li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第六章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li><li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li><li>官方一共将此系列分为12节，所以我也会分开写。</li><li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li><li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li></ul><hr><h2 id="✏️逆矩阵（Inverse-Matrices）："><a href="#✏️逆矩阵（Inverse-Matrices）：" class="headerlink" title="✏️逆矩阵（Inverse Matrices）："></a>✏️逆矩阵（Inverse Matrices）：</h2><h3 id="✍️矩阵的用途："><a href="#✍️矩阵的用途：" class="headerlink" title="✍️矩阵的用途："></a>✍️矩阵的用途：</h3><ul><li>操纵空间，并且线性代数几乎在所有技术领域都有体现。</li><li>它能帮助我们求解特定的方程组。</li><li>如果一个特定的方程里面它只存在常数和未知变量（没有幂，没有奇怪的函数，没有未知量间的乘积等等），我们整理这个方程组，将未知量放在左边，常数项放在右边；如果能对其未知变量就更好（必要情况下添加系数0）；此时，就被称为“<strong>线性方程组</strong>”（Linear system of equations）</li><li>此时我们可以将此整合成一个含有常数系数和未知变量的矩阵，以及他们乘积所得到的一个常数向量。</li><li><strong>（注意：此时先将范围限制在方程数目与未知量数目相等的情况内）</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E6%96%B9%E7%A8%8B%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5.png" alt="方程组和矩阵"></li><li>如上图，<strong>我们称系数矩阵为A，包含未知数的向量为粗体x，右侧的常数向量为v</strong>。这不仅仅是将方程组写进一行的书写技巧，它还阐明了这个问题中优美的几何直观部分。</li><li><strong>矩阵A代表一种线性变换，所以求解Ax&#x3D;v意味着我们去寻找一个向量x，使得它在变换后与v重合。</strong></li><li>所以求解此方程组，我们完全可以只考虑对空间的变换，以及变换后向量的重叠。</li></ul><hr><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%B8%A4%E4%B8%AA%E6%9C%AA%E7%9F%A5%E9%87%8F%E6%9E%84%E6%88%90%E7%9A%84%E6%96%B9%E7%A8%8B%E7%BB%84.png" alt="两个未知量构成的方程组"></p><ul><li>现在上图这个含有两个未知量构成的方程组，它的解依赖于矩阵A所代表的变换。</li><li>将空间挤压到一条线或一个点等低维空间，A保持空间为2维。</li><li>我们将它们分为两种情况：<ol><li>A的行列式为0。</li><li>A的行列式不为0。</li></ol></li></ul><h4 id="A的行列式不为0的情况："><a href="#A的行列式不为0的情况：" class="headerlink" title="A的行列式不为0的情况："></a>A的行列式不为0的情况：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/A%E7%9A%84%E8%A1%8C%E5%88%97%E5%BC%8F%E4%B8%8D%E4%B8%BA0.png" alt="A的行列式不为0"></p><ul><li>这种情况下，有且只有一个向量在变换后与v重合，并且可以通过逆向进行变换来找到这个向量。如同倒带一样，通过跟踪v的动向，就能找到满足Ax&#x3D;v的向量x。</li><li>当你逆向进行变换时，它实际上对应了另一个线性变换，通常被称为“A的逆”，记为A^(-1)。</li><li>这个过程在几何上就对应与逆向进行变换并跟踪v的动向。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/A%E7%9A%84%E9%80%86.png" alt="A的逆"></li><li>随机选一个矩阵，有很大的可能会遇到这一非零行列式的情况。也就是说，对于两个未知量和两个方程所构成的方程组存在它唯一的解。</li><li>当方程树木与未知量数目相同时，这一思想在高维情况下也有意义。同样也可以给方程组赋予几何意义。</li><li>只要保证A不将空间挤压到一个更低的维度，那么就是A的行列式不为零的情况，那他就存在逆变换（A逆）。这使得应用A变换在应用A逆变换之后，结果恒等。</li></ul><hr><h4 id="A的行列式为0的情况："><a href="#A的行列式为0的情况：" class="headerlink" title="A的行列式为0的情况："></a>A的行列式为0的情况：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/A%E7%9A%84%E8%A1%8C%E5%88%97%E5%BC%8F%E4%B8%BA0.png" alt="A的行列式为0"></p><ul><li>这个方程组相关的变换会压缩到更低的维度。</li><li>此时不存在逆变换，函数无法将一条线变换回一个平面。</li><li>此时的解依旧存在，向量v很可能恰好处于这条线上。三维空间时，解的存在难度就会更高。</li></ul><hr><h2 id="✏️秩（rank）："><a href="#✏️秩（rank）：" class="headerlink" title="✏️秩（rank）："></a>✏️秩（rank）：</h2><ul><li>当变换结果为一条直线时，也就是说结果是一维的，我们称这个变换的秩为1（Rank1）。</li><li>如果变换后的向量落在某个二维平面上，我们称这个变换的秩为2（Rank2）。</li><li><strong>所以说“秩”代表着变换后空间的维数。</strong></li><li>所以说对于2x2的矩阵，它的秩最大为2，意味着基向量仍旧能张成整个二维空间，并且矩阵的行列式不为0。</li><li>如果对于3x3矩阵来说，秩为2的时候意味着空间被压缩了，和秩为1的情况下相比较，压缩的并不是那么严重。</li><li>如果一个三维变换的行列式不为0，变换结果仍旧充满整个三维空间，那么它的秩为3。</li></ul><hr><h2 id="✏️列空间（Column-Space）："><a href="#✏️列空间（Column-Space）：" class="headerlink" title="✏️列空间（Column Space）："></a>✏️列空间（Column Space）：</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%9F%A9%E9%98%B5%E7%9A%84%E5%88%97%E7%A9%BA%E9%97%B4.png" alt="矩阵的列空间"></p><ul><li>无论是一条直线，一个平面还是三维空间，所有可能变换结果的集合被称为矩阵的“<strong>列空间</strong>”（Column Space）。</li><li>这个来源很简单，<strong>矩阵的列告诉你基向量变换后的位置。这些变换后的基向量张成的空间就是所有可能的变换结果</strong>。换句话说，<strong>列空间就是矩阵的列所张成的空间</strong>。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%88%97%E5%BC%A0%E6%88%90%E7%9A%84%E7%A9%BA%E9%97%B4.png" alt="列张成的空间"></li><li><strong>所以更精确的说，秩的定义是列空间的维数。</strong></li><li><strong>当秩达到最大值时，意味着秩与列数相等，我们称之为“满秩”（Full Rank）</strong></li></ul><hr><h3 id="✍️零空间（Null-space）："><a href="#✍️零空间（Null-space）：" class="headerlink" title="✍️零空间（Null space）："></a>✍️零空间（Null space）：</h3><ul><li>需要注意的是，零向量一定会被包含在列空间中，因为线性变换必须保证原点位置不变。</li><li>对于一个满秩变换来说，唯一能在变换后落在原点的就是零向量（0，0）自身。</li><li>但是对于一个非满秩的矩阵来说，他将空间压缩到一个更低的维度上，也就是说会有一系列向量在变换后成为零向量（被压缩的空间的有一部分会部分归到0向量）。</li><li>这被称为矩阵的“<strong>零空间</strong>”（Null Space）或“<strong>核</strong>”（Kernel）。</li><li>变换后的一些向量落在零向量上，而“零空间”正式这些向量所构成的空间。</li><li>对线性方程组来说，当向量v恰好为零向量时，零空间给出的就是这个向量方程所有可能的解。</li></ul><hr><h2 id="✏️总结："><a href="#✏️总结：" class="headerlink" title="✏️总结："></a>✏️总结：</h2><blockquote><p>每个方程组都有一个线性变换与之联系。<br>当逆变换存在时，你就能用这个逆变换求解方程组。<br>列空间的概念让我们清楚什么时候存在解什么时候不存在。<br>零空间的概念有助于我们理解所有可能的解的集合。</p></blockquote><hr><hr><hr><h2 id="✏️附注二："><a href="#✏️附注二：" class="headerlink" title="✏️附注二："></a>✏️附注二：</h2><h3 id="✍️非方阵（Nonsquare-Matrices）："><a href="#✍️非方阵（Nonsquare-Matrices）：" class="headerlink" title="✍️非方阵（Nonsquare Matrices）："></a>✍️非方阵（Nonsquare Matrices）：</h3><ul><li>在之前的学习中，使用的几乎都是2x2或者3x3这样的方形矩阵来举例子，但现在需要讨论一下非方阵。</li><li>讨论不同维数之间的变换是完全合理的，比如一个二维向量到三位向量的变换。</li><li>同之前一样，如果网格线保持平行且等距分布，并且原点映射为自身，就称它为线性的。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%BA%8C%E7%BB%B4%E5%90%91%E9%87%8F%E5%88%B0%E4%B8%89%E7%BB%B4%E5%90%91%E9%87%8F.png" alt="二维向量到三维向量"></li><li>此时要注意的是，由上图所示，输入的二维向量与输出的三维向量是完全不同的物种，他们生活在没有任何关联的空间当中。</li></ul><hr><h4 id="3x2矩阵："><a href="#3x2矩阵：" class="headerlink" title="3x2矩阵："></a>3x2矩阵：</h4><ul><li>用矩阵代表这样一个变换则和之前相同；找到每一个基向量变换后的位置，然后把基向量的坐标作为矩阵的列。如下图所示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20220927231819.png" alt="变换示例"></li><li>注意一点，这意味着代表这个变换的矩阵是三行两列，也就是3x2矩阵。这个矩阵的列空间是三维空间中一个过原点的二维平面，但是这个矩阵任然是满秩的。因为列空间的维数与输入空间的维数相等。</li><li>它的几何意义是将二维空间映射到三维空间上，因为矩阵有两列表面输入空间有两个基向量，有三行表明每个基向量在变换后都用三个独立的坐标来表示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/3x2%E7%9F%A9%E9%98%B5.png" alt="3x2矩阵"></li></ul><hr><h4 id="2x3矩阵："><a href="#2x3矩阵：" class="headerlink" title="2x3矩阵："></a>2x3矩阵：</h4><ul><li>类似的，当我们看见一个两行三列也就是2x3矩阵时，表面矩阵有三个基向量，也就是说原始空间是三维的；每个变换后的基向量用两个坐标来表示，所以他们一定落在二维空间。因此这是一个从三维空间到二维空间的变换。如下图所示例。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/2x3%E7%9F%A9%E9%98%B5%E7%A4%BA%E4%BE%8B.png" alt="2x3矩阵示例"></li></ul><hr><h4 id="1x2矩阵："><a href="#1x2矩阵：" class="headerlink" title="1x2矩阵："></a>1x2矩阵：</h4><ul><li>除此以外，当然还可以由二维空间到一维空间的转换，一维空间实际上就是数轴。</li><li>这里可以理解为如果一条直线上有一系列等距分布的点，在映射到数轴之后，他们将保持等距分布，这样的变换也可以用一个1x2矩阵表示，而这个矩阵的两列都只有一个数，这两列分别代表了变换后的基向量。</li><li>实际上这是一类非常有意义的变换，它与点积紧密相关。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/1x2%E7%9F%A9%E9%98%B5.png" alt="1x2矩阵"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;【&lt;strong&gt;注：本章笔记是第六章加附注二的笔记，也就是《逆矩阵，列空间与零空间》加《非方阵》。&lt;/strong&gt;】&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;3Blue1Brown-线代本质第六章：逆矩阵，列空间与零空间&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="-3Blue1Brown线性代数本质" scheme="http://example.com/categories/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%9C%AC%E8%B4%A8/"/>
    
    
    <category term="-学数学" scheme="http://example.com/tags/%E5%AD%A6%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>3Blue1Brown_线代本质第五章：行列式</title>
    <link href="http://example.com/2022/09/26/math_Essense_of_Linear_Algebra_P05/"/>
    <id>http://example.com/2022/09/26/math_Essense_of_Linear_Algebra_P05/</id>
    <published>2022-09-26T09:15:35.000Z</published>
    <updated>2022-09-26T15:53:09.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3Blue1Brown-线代本质第五章：行列式"><a href="#3Blue1Brown-线代本质第五章：行列式" class="headerlink" title="3Blue1Brown_线代本质第五章：行列式"></a>3Blue1Brown_线代本质第五章：行列式</h1><ul><li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第五章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li><li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li><li>官方一共将此系列分为12节，所以我也会分开写。</li><li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li><li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li></ul><hr><h2 id="✏️区域内面积增大减小："><a href="#✏️区域内面积增大减小：" class="headerlink" title="✏️区域内面积增大减小："></a>✏️区域内面积增大减小：</h2><ul><li>想象一些线性空间，有的变换是向外拉伸空间（Generally stretches space），有的则是向内挤压（Generally squashes space）；有件事情对理解这些线性变换很有用，那就是测量这些变换究竟对空间有多少拉伸或挤压；也就是：<strong>测量一个给定区域面积增大或减小的比例。</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%8F%98%E6%8D%A2%E5%90%8E%E7%9A%84%E9%9D%A2%E7%A7%AF.png" alt="变换后的面积"></li><li>如上图所示，i帽从（1，0）变换为（3，0），j帽从（0，1）变换为（0，2）；则由i帽和j帽决定的单位正方形的面积从原先的1x1变成了现在的3x2；它的面积增大了6倍。所以我们说这个线性变换将它的面积变为6倍。</li></ul><hr><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%89%AA%E5%88%87%E7%9F%A9%E9%98%B5%E7%9A%84%E9%9D%A2%E7%A7%AF%E5%8F%98%E6%8D%A2.png" alt="剪切矩阵的面积变换"></p><ul><li>【<strong>剪切矩阵</strong>】则是i帽不变还是在（1，0），j帽从（0，1）变为（1，1）；此时由i帽和j帽决定的单位正方形在变换后倾斜为一个平行四边形，但是它的面积是不变的。所以说即便这个变换空间向右挤压，它并不改变面积。</li><li>实际上，只要知道单位正方形面积变化的比例，他就能告诉你其他任意区域的面积变化比例（因为“网格线保持平行且等距分布”）。</li></ul><hr><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E8%BF%90%E7%94%A8%E8%BF%91%E4%BC%BC%E7%9A%84%E6%96%B9%E6%A0%BC%E7%BC%A9%E6%94%BE.png" alt="运用近似的方格缩放"></p><ul><li>对于不是方形网格的形状，我们可以用许多放个良好近似，只要使用的方格足够小，近似就能足够好。由于所有的小方格都是进行等比缩放，所以整个形状也进行了同样比例的缩放。</li></ul><hr><h2 id="✏️线性变换的行列式（The-“deternminant”-of-a-transformation）："><a href="#✏️线性变换的行列式（The-“deternminant”-of-a-transformation）：" class="headerlink" title="✏️线性变换的行列式（The “deternminant” of a transformation）："></a>✏️线性变换的行列式（The “deternminant” of a transformation）：</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E8%A1%8C%E5%88%97%E5%BC%8F.png" alt="线性变换行列式"></p><ul><li>比如说，一个线性变换的行列式是3，那么就是说他将一个区域的面积增加为原来的三倍。</li><li>同理一个线性变换的行列式是1&#x2F;2，那么就说他将一个区域的面积减少为原来的二分之一。</li><li>如果一个线性变换的行列式是0，那么说明它将整个平面压缩到一条线，甚至是一个点上。</li><li>如果变换前j帽在i帽的左侧，变换后j帽变成i帽的右侧，那么此时空间定向就发生了改变（Orientation has been reversed）。</li><li><strong>当空间定向改变，行列式为负</strong>，但是行列式的绝对值依然表示区域面积的缩放比例。</li></ul><hr><h3 id="✍️负的面积为什么与定向改变相关？"><a href="#✍️负的面积为什么与定向改变相关？" class="headerlink" title="✍️负的面积为什么与定向改变相关？"></a>✍️负的面积为什么与定向改变相关？</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E8%A1%8C%E5%88%97%E5%BC%8F%E4%B8%BA%E8%B4%9F%E5%80%BC%E7%9A%84%E6%83%85%E5%86%B5.png" alt="行列式为负值的情况"></p><ul><li>考虑i帽靠近j帽时的变换，空间也被更厉害的压缩，意味着行列式趋近于0；当i帽与j帽完全重合时，行列式为0。如果i帽继续沿着这个方向运动，则行列式继续减小为负值。</li></ul><hr><h2 id="✏️三维空间中行列式的变换："><a href="#✏️三维空间中行列式的变换：" class="headerlink" title="✏️三维空间中行列式的变换："></a>✏️三维空间中行列式的变换：</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E8%A1%8C%E5%88%97%E5%BC%8F%E5%9C%A8%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E5%86%85%E7%9A%84%E5%8F%98%E6%8D%A2.png" alt="行列式在三维空间内的变换"></p><ul><li>它告诉你的依然是变换前后的缩放比例，不过三维空间内缩放的是体积。</li><li>在三维空间中我们可以用1x1x1，即i，j，k这三个基向量，这个特殊的立方体来观察行列式的变换。</li><li>我们可以把行列式简单的看作这个平行六面体的体积<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%B9%B3%E8%A1%8C%E5%85%AD%E9%9D%A2%E4%BD%93%E7%9A%84%E4%BD%93%E7%A7%AF.png" alt="平行六面体的体积"></li><li>行列式为0则意味着整个空间被压缩为零体积的东西。也就是一个平面，一条直线或一个点。</li></ul><hr><h3 id="✍️如何计算行列式？："><a href="#✍️如何计算行列式？：" class="headerlink" title="✍️如何计算行列式？："></a>✍️如何计算行列式？：</h3><ul><li>首先它必须得是方形矩阵（行列数相等）。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E8%A1%8C%E5%88%97%E5%BC%8F%E9%9D%A2%E7%A7%AF%E8%AE%A1%E7%AE%97%E6%8E%A8%E5%AF%BC.png" alt="行列式面积计算推导"></li><li>ad是平行四边形的面积公式底乘以高，如果c不为0的情况下，这个bc项准确的告诉你平行四边形在对角线方向上拉伸或压缩了多少；则这个公式就可以计算出拉伸后的面积。</li></ul><h3 id="✍️三阶行列式计算公式："><a href="#✍️三阶行列式计算公式：" class="headerlink" title="✍️三阶行列式计算公式："></a>✍️三阶行列式计算公式：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%B8%89%E9%98%B6%E8%A1%8C%E5%88%97%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="三阶行列式计算公式"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3Blue1Brown-线代本质第五章：行列式&quot;&gt;&lt;a href=&quot;#3Blue1Brown-线代本质第五章：行列式&quot; class=&quot;headerlink&quot; title=&quot;3Blue1Brown_线代本质第五章：行列式&quot;&gt;&lt;/a&gt;3Blue1Brown_线代本质第</summary>
      
    
    
    
    <category term="-3Blue1Brown线性代数本质" scheme="http://example.com/categories/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%9C%AC%E8%B4%A8/"/>
    
    
    <category term="-学数学" scheme="http://example.com/tags/%E5%AD%A6%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>3Blue1Brown_线代本质第四章：矩阵乘法与线性变换复合；三维空间中的线性变换</title>
    <link href="http://example.com/2022/09/25/math_Essense_of_Linear_Algebra_P04/"/>
    <id>http://example.com/2022/09/25/math_Essense_of_Linear_Algebra_P04/</id>
    <published>2022-09-25T09:15:35.000Z</published>
    <updated>2022-09-25T12:12:26.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3Blue1Brown-线代本质第四章：矩阵乘法与线性变换复合"><a href="#3Blue1Brown-线代本质第四章：矩阵乘法与线性变换复合" class="headerlink" title="3Blue1Brown_线代本质第四章：矩阵乘法与线性变换复合"></a>3Blue1Brown_线代本质第四章：矩阵乘法与线性变换复合</h1><ul><li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第四章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li><li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li><li>官方一共将此系列分为12节，所以我也会分开写。</li><li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li><li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li></ul><hr><p>【<strong>注：本章笔记是第四章加附注一的笔记，也就是《矩阵乘法与线性变换复合》加《三维空间中的线性变换》。</strong>】</p><h2 id="✏️线性复合变换："><a href="#✏️线性复合变换：" class="headerlink" title="✏️线性复合变换："></a>✏️线性复合变换：</h2><ul><li>有时候，我们常常是想要做多种变换，比如“先旋转，后剪切”；这个新的线性变换通常被称为前两个独立变换的“<strong>复合变换</strong>”（Composition）。</li><li>和其他变换一样，我们可以通过追踪i帽和j帽的变换，并用矩阵完全描述这个复合变换。</li><li>两个矩阵相乘有着几何意义，也就是<strong>两个线性变换相继作用</strong>。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%A4%8D%E5%90%88%E7%9F%A9%E9%98%B5.png" alt="复合矩阵"></li><li>这个矩阵需要从右向左读；首先应用右侧矩阵所描述的变换，然后再应用左侧矩阵所描述的变换。</li><li>它起源于函数的记号，因为我们将函数写在变量左侧。所以每次将两个函数复合的时候，我们需要从右往左读。</li></ul><hr><h3 id="✍️复合矩阵的计算："><a href="#✍️复合矩阵的计算：" class="headerlink" title="✍️复合矩阵的计算："></a>✍️复合矩阵的计算：</h3><ul><li>我们希望对复合矩阵进行计算的时候，计算结果的第一列我们首先要考虑：<strong>i帽去哪里了？</strong></li><li>下图看出，i帽首先落在（1，1）。所以我们在计算时首先将示例中的M1的第一列（1，1）拿出来，与M2进行运算，将M2的变换作用于这个向量，得到最终计算结果的第一列。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%A4%8D%E5%90%88%E7%9F%A9%E9%98%B5%E7%A4%BA%E4%BE%8B_i%E5%B8%BD%E5%8F%98%E6%8D%A2.png" alt="复合矩阵示例_i帽变换"></li><li>其次，我们要考虑第二列：<strong>j帽去哪了？</strong></li><li>与上文中提到的i帽的计算方式一样，j帽先落在（-2，0），所以我们在计算时将示例中的M1的第一列（-2，0）拿出来，与M2进行运算，将M2的变换作用于这个向量，得到最终计算结果的第二列。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%A4%8D%E5%90%88%E7%9F%A9%E9%98%B5%E7%A4%BA%E4%BE%8B_j%E5%B8%BD%E5%8F%98%E6%8D%A2.png" alt="复合矩阵示例_j帽变换"></li><li>这一推理具有普适性，对任意矩阵都适用。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E5%85%AC%E5%BC%8F.png" alt="矩阵乘法公式"></li></ul><h3 id="✍️注意矩阵计算顺序不可对调："><a href="#✍️注意矩阵计算顺序不可对调：" class="headerlink" title="✍️注意矩阵计算顺序不可对调："></a>✍️注意矩阵计算顺序不可对调：</h3><ul><li><strong>矩阵乘法不具有交换律。</strong></li><li>如之前的推导公式中，M1M2≠M2M1；即在矩阵运算中“先剪切，后旋转”并不等于“先旋转，后剪切”。</li><li>乘积顺序影响整体的计算。</li></ul><h3 id="✍️结合律（Associativity）："><a href="#✍️结合律（Associativity）：" class="headerlink" title="✍️结合律（Associativity）："></a>✍️结合律（Associativity）：</h3><ul><li><strong>矩阵乘法满足结合律</strong>。</li><li><strong>A（BC） &#x3D; （AB）C</strong></li><li>空间变换来看，线性变换的作用对象是向量，这个计算是线性变换的复合，而不是指把一个作用于另一个。</li><li>以上的等式左边是在说：首先应用C变换和B变换，然后应用A变换；等式右边还是在说：首先应用C变换，其次应用B变换和A变换。</li><li>这只是将同样的三个变换用同样的顺序依次总用，换句话说就是：添加括号与结果无关，他们的计算顺序没有变化（记住矩阵变换始终是从右往左读的）。括号的意义在这里表示某两个要一起做，而不是他们做的顺序提前。</li></ul><hr><hr><hr><h2 id="✏️三维空间中的线性变换："><a href="#✏️三维空间中的线性变换：" class="headerlink" title="✏️三维空间中的线性变换："></a>✏️三维空间中的线性变换：</h2><ul><li>考虑这样一个线性变换，他以三维向量为输入，并以三维向量为输出；我们可以想象他在移动三维空间中的所有点，保持网格线平行且等距分布，并保持原点不动。</li><li>和二维的情形一样，我们看见三维空间中每一个点实际上只是用来代表以它本身为终点的一个向量；而我们所做的变换只是将输入向量移动至对应向量。</li><li>三维线性的变换由基向量的去向完全决定。</li><li>此时就有3个基向量，分别是x方向的i帽，y方向的j帽，z方向的k帽。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8F%98%E6%8D%A2.png" alt="三维空间的变换"></li><li>将变换后的三个基向量的坐标记录在一个3x3的矩阵中。这九个数字就完全描述了一个线性变换。</li><li>三维空间内向量的变换公式推导与二维空间几乎一致，它每个坐标都可以看作对相应基向量的缩放。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/3x3%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2.png" alt="3x3矩阵变换"></li><li>3x3矩阵的运用十分广泛,如计算机图形学（Computer Graphics）与机器人学（Robotics）。</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3Blue1Brown-线代本质第四章：矩阵乘法与线性变换复合&quot;&gt;&lt;a href=&quot;#3Blue1Brown-线代本质第四章：矩阵乘法与线性变换复合&quot; class=&quot;headerlink&quot; title=&quot;3Blue1Brown_线代本质第四章：矩阵乘法与线性变换复</summary>
      
    
    
    
    <category term="-3Blue1Brown线性代数本质" scheme="http://example.com/categories/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%9C%AC%E8%B4%A8/"/>
    
    
    <category term="-学数学" scheme="http://example.com/tags/%E5%AD%A6%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>3Blue1Brown_线代本质第三章：矩阵与线性变换</title>
    <link href="http://example.com/2022/09/24/math_Essense_of_Linear_Algebra_P03/"/>
    <id>http://example.com/2022/09/24/math_Essense_of_Linear_Algebra_P03/</id>
    <published>2022-09-24T09:15:35.000Z</published>
    <updated>2022-09-25T09:18:42.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3Blue1Brown-线代本质第三章：矩阵与线性变换"><a href="#3Blue1Brown-线代本质第三章：矩阵与线性变换" class="headerlink" title="3Blue1Brown_线代本质第三章：矩阵与线性变换"></a>3Blue1Brown_线代本质第三章：矩阵与线性变换</h1><ul><li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第三章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li><li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li><li>官方一共将此系列分为12节，所以我也会分开写。</li><li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li><li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li></ul><hr><h2 id="✏️线性变换："><a href="#✏️线性变换：" class="headerlink" title="✏️线性变换："></a>✏️线性变换：</h2><p>【<strong>注</strong>：这章节讨论在二维空间的样子，以及与矩阵向量乘法的关联，并展示一种不用死记硬背的考虑矩阵向量乘法的方法。】</p><h3 id="✍️解析“线性变换”："><a href="#✍️解析“线性变换”：" class="headerlink" title="✍️解析“线性变换”："></a>✍️解析“线性变换”：</h3><ul><li>Linear Transformation &#x3D; Linear Function</li><li>“变换”（Transformation）本质上是“函数”（function）的一种花哨的说法；它接受输入内容，并输出对应结果。</li><li>变换和函数意义相同还要用不同的词汇表达的原因是：使用“变换”是在暗示以特定的方式来可视化这一“输入”“输出”关系；“变换”这个词在按时我们用运动去思考。</li><li>每一个输入向量都移动到输出向量的位置：将向量看作是点，那么变换就是空间中的点移动到其他点的位置。</li><li><strong>直观的说，如果一个变换具有以下两条性质，我们就可以称它是线性的</strong>：<br>  <strong>1. 直线在变换后仍然保持为直线，不能有所弯曲。</strong><br>  <strong>2. 原点保持固定。</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E8%A7%84%E5%88%99.png" alt="线性变换规则"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20220924214734.png" alt="20220924214734"></li><li><strong>总的来说，可以把线性变换看作是“保持网格线平行且等距分布”的变换</strong>。部分线性变换比较容易思考，如：网格以原点为轴心进行旋转；其他的则稍加复杂。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2.png" alt="线性变换"></li></ul><hr><h3 id="✍️如何用数值描述线性变换："><a href="#✍️如何用数值描述线性变换：" class="headerlink" title="✍️如何用数值描述线性变换："></a>✍️如何用数值描述线性变换：</h3><ul><li><p>我们给出一个向量坐标，希望得到一个变换后向量的坐标只需要通过：</p><ul><li><strong>记录两个基向量i帽和j帽变换后的位置，其他向量也会随之而动</strong></li></ul></li><li><p>由下图可视，向量v的坐标原本为（-1，2），这个向量可以看作为-1与i帽之积和2与j帽之基的和。如果运用一些变换，使得向量一起运动，并尊重“网格保持平行且等距分布”这个原则，变换后的向量v的位置，就是-1与变换后i帽之积加上2与变换后j帽之积。</p></li><li><p>换句话说，向量v是i帽和j帽的一个特定线性组合；那么变换后的向量v也是变换后i帽与j帽同样的线性组合。这就意味着，你可以只根据变换后的i帽与j帽，就推断出变化后的v。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E6%95%B0%E5%80%BC%E6%8F%8F%E8%BF%B0%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2.png" alt="数值描述线性变换"></p></li><li><p>一般情况下，一个向量的坐标是（x，y），变换后的向量就是x乘变换后的i帽，加上y乘变换后的j帽。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%85%AC%E5%BC%8Fpng.png" alt="公式png"></p></li><li><p>一个二维线性变换仅由四个数字完全确定：变换后i帽的两个坐标与变换后j帽的两个作坐标。</p></li><li><p>通常我们将这些坐标装在一个2x2的格子中，称它为2x2矩阵。</p></li></ul><hr><h2 id="✏️矩阵："><a href="#✏️矩阵：" class="headerlink" title="✏️矩阵："></a>✏️矩阵：</h2><ul><li>如果有一个描述线性变换的2x2矩阵，以及一个给定的初始向量，你只需要取初始向量的坐标，将他们分别于矩阵的特定列相乘，然后结果相加即可。这与“缩放基向量再相加”的思想一致。</li><li><strong>矩阵在这里只是一个记号，它含有描述线性变换的信息。</strong></li><li>如下图所示：我们可以把矩阵的第一列（a，c）看作是变换后第一个基向量，把第二列（b，d）看作是变换后第二个基向量；我们将这个变换作用于向量（x，y），它的结果就是（ax+by，cx+dy）。我们可以把它定义为<strong>矩阵向量乘法</strong>。<strong>矩阵放在向量左边，类似一个函数</strong>。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/2x2%E7%9F%A9%E9%98%B5%E5%85%AC%E5%BC%8F.png" alt="2x2矩阵公式"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%9F%A9%E9%98%B5%E5%90%91%E9%87%8F%E4%B9%98%E6%B3%95.png" alt="矩阵向量乘法"></li><li><strong>我们完全可以把矩阵的列看作变换后的基向量，把矩阵向量的乘法看作他们的线性组合。</strong></li><li>线性变换是操纵空间的一种手段；这种变换只需要几个数字就可以描述清楚，这些数字就是变换后的基向量的坐标。</li></ul><hr><h3 id="✍️示例：逆时针旋转90度"><a href="#✍️示例：逆时针旋转90度" class="headerlink" title="✍️示例：逆时针旋转90度"></a>✍️示例：逆时针旋转90度</h3><ul><li>如下图示例，i帽初始为（1，0），j帽初始为（0，1）；如果将他们逆时针旋转90度，那么变换后的i帽就是（0，-1），j帽就是（-1，0）。</li><li>如果此时我们想计算一个向量逆时针旋转90度：可以直接将这个向量（x，y）与变换后的i帽与j帽相乘。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%90%91%E9%87%8F%E9%80%86%E6%97%B6%E9%92%88%E6%97%8B%E8%BD%AC90%E5%BA%A6%E6%A1%88%E4%BE%8B.png" alt="向量逆时针旋转90度案例"></li></ul><hr><h3 id="✍️Shear（剪切-x2F-错切）："><a href="#✍️Shear（剪切-x2F-错切）：" class="headerlink" title="✍️Shear（剪切&#x2F;错切）："></a>✍️Shear（剪切&#x2F;错切）：</h3><ul><li>i帽保持为（1，0），j帽移动到坐标（1，1）。为了计算一个向量变换后的位置，可以直接将向量与这个矩阵相乘。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20220925165136.png" alt="shear"></li></ul><hr><h3 id="✍️反向思考："><a href="#✍️反向思考：" class="headerlink" title="✍️反向思考："></a>✍️反向思考：</h3><ul><li>如果我们希望推测一个矩阵代表的线性变换是什么样的，我们可以将i帽与j帽先移动到变换后的位置，空间其他剩余部分则跟随二者一起运动，以保持网格线平行且等距分布。</li><li>如果变换后的i帽和变换后的j帽是线性相关的，意味着其中一个向量是另一个的倍数，那么这个线性变换将整个二维空间挤压到他们所在的一条直线上，也就是这儿两个线性相关向量所张成的一维空间。</li></ul><hr><h2 id="✏️总结："><a href="#✏️总结：" class="headerlink" title="✏️总结："></a>✏️总结：</h2><ul><li><strong>总之，线性变换是操纵空间的一种手段，它保持网格线平行且等距分布，并且保持原点不动。</strong></li><li>这种变换只需要几个数字就能够描述清楚，这些数字就是变换后基向量的坐标；以这些坐标为列所构成的矩阵为我们提供了一种描述线性变换的语言。矩阵向量乘法就是计算线性变换作用于给定向量的一种途径。</li><li>矩阵都可以理解为对空间的一种特定变换。</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3Blue1Brown-线代本质第三章：矩阵与线性变换&quot;&gt;&lt;a href=&quot;#3Blue1Brown-线代本质第三章：矩阵与线性变换&quot; class=&quot;headerlink&quot; title=&quot;3Blue1Brown_线代本质第三章：矩阵与线性变换&quot;&gt;&lt;/a&gt;3Blue</summary>
      
    
    
    
    <category term="-3Blue1Brown线性代数本质" scheme="http://example.com/categories/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%9C%AC%E8%B4%A8/"/>
    
    
    <category term="-学数学" scheme="http://example.com/tags/%E5%AD%A6%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>3Blue1Brown_线代本质第二章：线性组合，张成的空间与基</title>
    <link href="http://example.com/2022/09/22/math_Essense_of_Linear_Algebra_P02/"/>
    <id>http://example.com/2022/09/22/math_Essense_of_Linear_Algebra_P02/</id>
    <published>2022-09-22T09:15:35.000Z</published>
    <updated>2022-09-23T08:36:53.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3Blue1Brown-线代本质第二章：线性组合，张成的空间与基"><a href="#3Blue1Brown-线代本质第二章：线性组合，张成的空间与基" class="headerlink" title="3Blue1Brown_线代本质第二章：线性组合，张成的空间与基"></a>3Blue1Brown_线代本质第二章：线性组合，张成的空间与基</h1><ul><li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第二章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li><li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li><li>官方一共将此系列分为12节，所以我也会分开写。</li><li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li><li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li></ul><hr><h2 id="✏️基向量："><a href="#✏️基向量：" class="headerlink" title="✏️基向量："></a>✏️基向量：</h2><h3 id="✍️在xy坐标系中两个特殊向量："><a href="#✍️在xy坐标系中两个特殊向量：" class="headerlink" title="✍️在xy坐标系中两个特殊向量："></a>✍️在xy坐标系中两个特殊向量：</h3><ul><li>一个指向正右方，长度为1，通常被称为“i-hat”（i帽）或x方向的单位向量。</li><li>另一个指向正上方，长度为1，通常被称为“j-hat”（j帽）或者y方向的单位向量。</li><li><strong>i-hat与j-hat这两个向量有特殊的名称，他们是xy坐标轴的“基向量”（basis vector）。</strong></li><li>这是在表述：当你把坐标看为标量时，基向量实际上就是这些标量的缩放对象。</li></ul><hr><h3 id="✍️例子1："><a href="#✍️例子1：" class="headerlink" title="✍️例子1："></a>✍️例子1：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/ihat_jhat.png" alt="ihat_jhat"></p><ul><li><strong>由上图示意看出，（3，-2）可以想象为</strong>：x坐标是一个标量，它将i帽拉升为原来的三倍；y坐标也是一个标量，它将j帽反向并拉伸为原来的两倍。从这个角度看，这个向量实际上是两个经过缩放的向量的和。</li><li>“<strong>缩放向量并且相加</strong>”这一概念十分重要。</li></ul><hr><h3 id="✍️如果我们选择不同的基向量会怎么样："><a href="#✍️如果我们选择不同的基向量会怎么样：" class="headerlink" title="✍️如果我们选择不同的基向量会怎么样："></a>✍️如果我们选择不同的基向量会怎么样：</h3><ul><li><strong>我们完全可以选择不同的基向量，获得一个合理的新坐标系。</strong></li><li>比如随便选一个指向右上方的向量，再随便选择一个指向右下方的向量，想象通过选择两个标量，分别用于缩放二者的其中一个， 然后把他们相加，就可以得到不同的结果。通过改变所选择的向量，我们可以得到所有向量。</li><li>一对新的基向量，同样允许我们在一对数和二维向量之间自由转化。但是这种变化关系与我们之前使用的i帽和j帽的变化关系完全不同。</li><li><strong>每当我们用数字描述向量的时候，它都依赖于我们正在使用的基。</strong></li><li><strong>两个数乘向量的和被称为这两个向量的线性组合（Linear combination）。</strong></li><li><strong>那么线性怎么来的可以考虑为：</strong> 如果固定其中一个标量，让另一个标量自由变化，所产生的终点会描述出一条直线，如下图所示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/linearCombination.png" alt="linearCombination"></li></ul><hr><ul><li><strong>如果让两个标量同时自由变换，考虑所有可得到的向量，可能有两种情况（实际是三种）：</strong><ol><li>大部分情况下，对于一对初始向量，你能达到平面中每一个点；所有二维向量都尽在掌握。</li><li>另一种较为糟糕的情况是，当两个初始向量恰好共线时，所产生的向量的终点被限制在一条过原点的直线上。</li><li>事实上还有第三种情况就是，两个向量都是零向量,那就只能在原点了。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%90%91%E9%87%8F%E5%8F%98%E6%8D%A2%E7%9A%84%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5.png" alt="向量变换的三种情况"></li></ol></li></ul><hr><h2 id="✏️张成空间（span）："><a href="#✏️张成空间（span）：" class="headerlink" title="✏️张成空间（span）："></a>✏️张成空间（span）：</h2><p><strong>概念：</strong><br>    - <strong>所有可以表示为给定向量线性组合的向量的集合，被成为给定向量张成的空间。</strong></p><ul><li>下图：向量全部线性组合构成的向量集合成为“张成的空间”，a与b在实数范围内变动。</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%BC%A0%E6%88%90%E7%A9%BA%E9%97%B4.png" alt="张成空间"></li></ul><h3 id="✍️二维空间内张成空间："><a href="#✍️二维空间内张成空间：" class="headerlink" title="✍️二维空间内张成空间："></a>✍️二维空间内张成空间：</h3><ul><li>通常情况下，我们用向量的终点代表向量（起点是原点）；用这种方法来看，如果要考虑落在一条直线上所有向量的时候，只需要考虑直线本身就行了。所以也可以考虑为，如果同时考虑xy坐标系中所有向量，将每个向量抽象为它的终点，实际上就不用考虑所有的肩头了，只需要考虑无限大的二维平面本身即可。</li><li>如果考虑一个向量，我们就可以把他看作箭头；如果考虑多个向量，则可以把他们都看作是点。</li><li>对大部分二维向量来说，它们的张成空间是整个无限大的二维平面；但如果共线，他们的张成空间就是一条直线。</li></ul><hr><h3 id="✍️三维空间内张成空间："><a href="#✍️三维空间内张成空间：" class="headerlink" title="✍️三维空间内张成空间："></a>✍️三维空间内张成空间：</h3><h4 id="在三维空间中取两个指向不同方向的向量，他们的张成空间是这样的："><a href="#在三维空间中取两个指向不同方向的向量，他们的张成空间是这样的：" class="headerlink" title="在三维空间中取两个指向不同方向的向量，他们的张成空间是这样的："></a>在三维空间中取两个指向不同方向的向量，他们的张成空间是这样的：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%B8%A4%E4%B8%AA%E5%90%91%E9%87%8F%E5%9C%A8%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4.png" alt="两个向量在三维空间"></p><ul><li>这两个向量的张成空间就是他们所有可能的线性组合；也就是缩放再相加之后所有可得到的向量。</li><li>逐渐改变线性组合中的这两个标量，把缩放后的向量相加，然后跟着最终向量的终点走，这个终点会画出三维空间中某个过原点的平面；这个平面就是这两个向量的张成空间。（所有终点落在这个平面上的向量集合是这两个向量的张成空间）</li></ul><h4 id="如果加上第三个向量，他们的张成空间是这样的："><a href="#如果加上第三个向量，他们的张成空间是这样的：" class="headerlink" title="如果加上第三个向量，他们的张成空间是这样的："></a>如果加上第三个向量，他们的张成空间是这样的：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%B8%89%E4%B8%AA%E5%90%91%E9%87%8F%E5%9C%A8%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4.png" alt="三个向量在三维空间"></p><ul><li>选择三个向量分别进行缩放，然后把结果相加。</li><li>这三个向量所有可能的线性作何构成了他们的张成空间。</li><li>如果第三个向量恰好落在前两个向量所张成的平面上，那么他们张成的空间并不改变，还是在这个平面中。</li><li>但是如果随机选一个向量，他几乎不可能落在前两个向量所张成的平面中；这种情况下，由于第三个向量指向不同的方向，我们就能得到所有的三维向量。（可以考虑成：当我们缩放第三个向量的时候，他将前两个向量张成平面来回沿着它的方向移动，从而扫过整个三维空间。）</li></ul><hr><h2 id="✏️Linearly-dependent-和-Linearly-Independent："><a href="#✏️Linearly-dependent-和-Linearly-Independent：" class="headerlink" title="✏️Linearly dependent 和 Linearly Independent："></a>✏️Linearly dependent 和 Linearly Independent：</h2><h4 id="当向量共线的情况，或第三个向量恰好落在之前向量生成的平面的情况下："><a href="#当向量共线的情况，或第三个向量恰好落在之前向量生成的平面的情况下：" class="headerlink" title="当向量共线的情况，或第三个向量恰好落在之前向量生成的平面的情况下："></a>当向量共线的情况，或第三个向量恰好落在之前向量生成的平面的情况下：</h4><ul><li>这种情况说明一组向量中至少有一个是多余的，没有对张成空间做出任何贡献，我们取走这个多余的向量也不减少张成空间，这样的情况下，我们称它为“<strong>线性相关</strong>”（<strong>Linearly dependent</strong>）的。</li></ul><h4 id="如果所有向量都给张成空间添加了新的维度："><a href="#如果所有向量都给张成空间添加了新的维度：" class="headerlink" title="如果所有向量都给张成空间添加了新的维度："></a>如果所有向量都给张成空间添加了新的维度：</h4><ul><li>这种情况就称之为“<strong>线性无关</strong>”（<strong>Linearly Independent</strong>）的。</li></ul><hr><h2 id="✏️基的严格定义（Technical-definition-of-basis）："><a href="#✏️基的严格定义（Technical-definition-of-basis）：" class="headerlink" title="✏️基的严格定义（Technical definition of basis）："></a>✏️基的严格定义（Technical definition of basis）：</h2><ul><li>The basis of a vector space is a set of linearly independent vectors that span the full space<br>(向量空间的一组基是张成该空间的一个线性无关向量集)<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%9F%BA%E7%9A%84%E4%B8%A5%E6%A0%BC%E5%AE%9A%E4%B9%89.png" alt="基的严格定义"></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3Blue1Brown-线代本质第二章：线性组合，张成的空间与基&quot;&gt;&lt;a href=&quot;#3Blue1Brown-线代本质第二章：线性组合，张成的空间与基&quot; class=&quot;headerlink&quot; title=&quot;3Blue1Brown_线代本质第二章：线性组合，张成的</summary>
      
    
    
    
    <category term="-3Blue1Brown线性代数本质" scheme="http://example.com/categories/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%9C%AC%E8%B4%A8/"/>
    
    
    <category term="-学数学" scheme="http://example.com/tags/%E5%AD%A6%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>3Blue1Brown_线代本质第一章：向量究竟是什么</title>
    <link href="http://example.com/2022/09/22/math_Essense_of_Linear_Algebra_P01/"/>
    <id>http://example.com/2022/09/22/math_Essense_of_Linear_Algebra_P01/</id>
    <published>2022-09-22T09:15:35.000Z</published>
    <updated>2022-09-23T08:42:37.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3Blue1Brown-线代本质第一章：向量究竟是什么"><a href="#3Blue1Brown-线代本质第一章：向量究竟是什么" class="headerlink" title="3Blue1Brown_线代本质第一章：向量究竟是什么"></a>3Blue1Brown_线代本质第一章：向量究竟是什么</h1><ul><li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li><li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li><li>官方一共将此系列分为12节，所以我也会分开写。</li><li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li><li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li></ul><hr><h2 id="✏️向量基本解释："><a href="#✏️向量基本解释：" class="headerlink" title="✏️向量基本解释："></a>✏️向量基本解释：</h2><ul><li><strong>在线性代数中，最基础，最根源的组成部分就是向量</strong></li><li><strong>一般来说，有三种看待向量的观点，他们看似不同却有所关联。</strong><ul><li>物理专业的角度</li><li>数学角度</li><li>计算机角度</li></ul></li></ul><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/vector.png" alt="vector"></p><hr><h3 id="📝物理专业的角度："><a href="#📝物理专业的角度：" class="headerlink" title="📝物理专业的角度："></a>📝物理专业的角度：</h3><ul><li><strong>向量是空间中的箭头。</strong></li><li>决定一个向量的是：<ol><li>它的长度。</li><li>它所指的方向。</li></ol></li><li>只要上述两个特征不改变，就可以自由移动一个向量而保持它本身不被改变。</li><li>处在平面中的向量是二维的。</li><li>处在生活空间中的向量是三维的。</li></ul><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/2vs3Dimensional.png" alt="2vs3Dimensional"></p><hr><h3 id="📝计算机角度："><a href="#📝计算机角度：" class="headerlink" title="📝计算机角度："></a>📝计算机角度：</h3><ul><li><strong>向量是有序的数字列表。</strong></li><li>比如你正在做一个有关房价的分析，你关心的只有两个特征：<ol><li>房屋面积。</li><li>房屋价格。</li></ol></li><li>注意数字列表的<strong>数字顺序不可颠倒</strong></li><li>在这个房屋的例子里可以表述为：用二维向量对房屋进行建模。</li><li>在这里，向量只不过是列表的一个花哨的说法，这个向量是二维的因为它的列表长度是2。</li></ul><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/cs_vector.png" alt="csStudent_vector"></p><hr><h3 id="📝数学角度："><a href="#📝数学角度：" class="headerlink" title="📝数学角度："></a>📝数学角度：</h3><ul><li><strong>向量可以是任何东西，只要保证两个向量相加以及数字与向量相乘是有意义的即可。</strong></li><li>这种方式看待向量就较为抽象了。这里可以看出，向量加法和向量数乘贯穿线性代数，二者起着很重要的作用。</li></ul><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/math_vector.png" alt="math_vector"></p><hr><h2 id="✏️向量思考方式："><a href="#✏️向量思考方式：" class="headerlink" title="✏️向量思考方式："></a>✏️向量思考方式：</h2><ul><li>首先考虑一个坐落在某个坐标系（例如x-y平面）中的箭头，箭头起点位于原点。</li><li>在线性代数中，向量经常以原点作为起点；这与物理学理念（向量可以在空间中自由落脚）不同。</li><li>一旦理解了【向量是空间中的箭头】，那么我们可以通过【向量坐标】来理解【向量是一个有序数字列表】</li><li>因为这两种观念的碰撞，恰恰形成了线性代数中的重要概念。</li></ul><hr><h3 id="📝平面空间内："><a href="#📝平面空间内：" class="headerlink" title="📝平面空间内："></a>📝平面空间内：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/vector%E5%B9%B3%E9%9D%A2%E7%A9%BA%E9%97%B4.png" alt="vector平面空间"></p><ul><li>来看这个箭头在x-y平面空间内（每个间距单位为1），它的这对数指导我们如何从原点（向量起点）出发到达它的尖端（向量终点）。</li><li>第一个数告诉我们沿着x轴走多远，正数代表向右移动，负数代表向左移动。</li><li>第二个数告诉我们沿着y轴走多远。正数代表向上移动，负数代表向下移动。</li><li>为了把向量和点区别开，向量采用的写法是将这对数竖着写，并用方括号括起来。（（-2，3）这样表示的向量也是可以的，没有区别）。</li><li>每一对数给出为一一个向量（有且只有一个）。</li><li>每一个向量恰好对应为一一对数。</li></ul><hr><h3 id="📝三维空间内："><a href="#📝三维空间内：" class="headerlink" title="📝三维空间内："></a>📝三维空间内：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E5%90%91%E9%87%8F1.png" alt="三维空间向量1"></p><ul><li>三维空间内我们再添加一个垂直于x轴和y轴的第三根z轴</li><li>这种情况下，每个向量就与一个有序的三元数组对应。</li><li>第一个数告诉你沿平行x轴走多远，第二个数告诉你沿平行y轴走多远，第三个数告诉你沿平行z轴走多远。</li><li>每个三元数组给出为一一个向量。</li><li>每个向量对应唯一的三元数组。</li></ul><hr><h3 id="📝向量加法和向量数乘："><a href="#📝向量加法和向量数乘：" class="headerlink" title="📝向量加法和向量数乘："></a>📝向量加法和向量数乘：</h3><ul><li>线性代数中每一个主题都围绕着这两种运算。</li></ul><h4 id="✍️向量加法："><a href="#✍️向量加法：" class="headerlink" title="✍️向量加法："></a>✍️向量加法：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/vectorSum.png" alt="vectorSum"></p><ul><li>向量加法：<ul><li>我们通过平移第二个向量，使他的起点与第一个向量的终点重合；然后画一个向量，它从第一个向量的起点出发，指向第二个向量的终点；这个向量就是他们的和</li></ul></li><li>向量加法的定义差不多是线代中唯一允许向量离开原点的情形。</li><li>我们可以把向量加法看作数轴上加法的一种扩展。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E6%95%B0%E8%BD%B4%E5%8A%A0%E6%B3%95.png" alt="数轴加法"></li><li>回到x-y平面内，我们可以以下图方式所思考向量的加法，即：它朝着x轴，y轴分别运动的总量；先完成它水平运动，再完成竖直运动。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%90%91%E9%87%8F%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97%E6%96%B9%E5%BC%8F.png" alt="向量加法运算方式"></li></ul><hr><h4 id="✍️向量数乘："><a href="#✍️向量数乘：" class="headerlink" title="✍️向量数乘："></a>✍️向量数乘：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%90%91%E9%87%8F%E6%95%B0%E4%B9%98.png" alt="向量数乘"></p><ul><li>向量与其他数（标量）相乘的方式叫做“Scaling”（缩放）。</li><li>数字（标量）在线性代数的作用就是缩放向量；负数与向量相乘则会改变向量的方向。</li></ul><hr><h3 id="📝总结："><a href="#📝总结：" class="headerlink" title="📝总结："></a>📝总结：</h3><ul><li><strong>怎么看待向量都无所谓，它的实际作用也很少体现在这些观点的其中一个上，而是更多的体现在它能够在这些观点中相互转化。</strong></li><li>线性代数为数据分析提供了一条将大量数据列表概念化，可视化的渠道。他让数据样式变得非常明晰，并让我们了解特定运算的意义。</li><li>另一方面，线代给物理学家和计算机图形程序员提供了一种语言，让他们通过计算机能处理的数字来描述并操纵空间。</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3Blue1Brown-线代本质第一章：向量究竟是什么&quot;&gt;&lt;a href=&quot;#3Blue1Brown-线代本质第一章：向量究竟是什么&quot; class=&quot;headerlink&quot; title=&quot;3Blue1Brown_线代本质第一章：向量究竟是什么&quot;&gt;&lt;/a&gt;3Blue</summary>
      
    
    
    
    <category term="-3Blue1Brown线性代数本质" scheme="http://example.com/categories/3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%9C%AC%E8%B4%A8/"/>
    
    
    <category term="-学数学" scheme="http://example.com/tags/%E5%AD%A6%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Light_a_Project_in_UE</title>
    <link href="http://example.com/2022/09/18/ue_Light_a_Project_in_UE/"/>
    <id>http://example.com/2022/09/18/ue_Light_a_Project_in_UE/</id>
    <published>2022-09-18T09:23:33.000Z</published>
    <updated>2022-09-18T14:07:23.576Z</updated>
    
    <content type="html"><![CDATA[<p><strong>🍊这篇是UE的灯光与烘培的学习笔记，不大全面，有问题请随时指正🍊</strong><br>🍊这里是b站<a href="https://www.bilibili.com/video/BV17K4y1L7Gf/?spm_id_from=333.788.recommend_more_video.3&vd_source=95a1cfccd5b1e6779677de477b25aa31%5C">链接</a>🍊</p><hr><h1 id="Unreal-灯光照明与烘培"><a href="#Unreal-灯光照明与烘培" class="headerlink" title="Unreal 灯光照明与烘培"></a>Unreal 灯光照明与烘培</h1><h2 id="🚩【主要涵盖的话题】"><a href="#🚩【主要涵盖的话题】" class="headerlink" title="🚩【主要涵盖的话题】"></a>🚩【主要涵盖的话题】</h2><ol><li>技术和艺术的讨论</li><li>资产和场景的准备</li><li>灯光烘培设置</li><li>动态照明设置</li><li>图像基础的灯光设置</li><li>阴影</li><li>反射</li></ol><hr><h2 id="🚩【一：目标媒介】"><a href="#🚩【一：目标媒介】" class="headerlink" title="🚩【一：目标媒介】"></a>🚩【一：目标媒介】</h2><ul><li>考虑项目是否会定义到移动设备，或者是在一些需要高保真的媒体设备使用</li><li>每个镜头都是独立的视频项目的编辑方案</li><li>对于24FPS，30FPS和60FPS的项目的不同处理的方案</li><li>不需要完全实时渲染的项目</li><li>如果整个项目都是静态的，那么可以预先烘培</li><li>开放世界的灯光无法提前烘培，所以需要light map并使用动态照明处理</li><li>考虑硬件的最低规格</li></ul><hr><h2 id="🚩【二：Deferred-Renderer和Forward-Renderer】"><a href="#🚩【二：Deferred-Renderer和Forward-Renderer】" class="headerlink" title="🚩【二：Deferred Renderer和Forward Renderer】"></a>🚩【二：Deferred Renderer和Forward Renderer】</h2><h3 id="🥕Deferred-Renderer："><a href="#🥕Deferred-Renderer：" class="headerlink" title="🥕Deferred Renderer："></a>🥕Deferred Renderer：</h3><ul><li>是UE4的默认渲染器</li><li>它的工作方式就是储存所有原始数据在Screen Space Buffers（Color，Normal，Depth，…）然后将他们组合到一起成为Final Image</li><li>照明灯光一起评估</li><li>额外的screen space则会被用在更复杂的后处理效果与照明效果的组合</li><li>支持所有的渲染功能</li></ul><h3 id="🥕Forward-Renderer："><a href="#🥕Forward-Renderer：" class="headerlink" title="🥕Forward Renderer："></a>🥕Forward Renderer：</h3><ul><li>为了VR开发的</li><li>所有的lighting和shading都在object draw time进行评估计算</li><li>可以做特有的材质优化</li><li>更多的抗锯齿操作</li></ul><hr><h2 id="🚩【三：如何给一套好的照明准备资产】"><a href="#🚩【三：如何给一套好的照明准备资产】" class="headerlink" title="🚩【三：如何给一套好的照明准备资产】"></a>🚩【三：如何给一套好的照明准备资产】</h2><ol><li><strong>确保材质是物理正确的</strong><br> <img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/matRef.png" alt="matRef"><br>   常见问题有：<ul><li><ol><li>base color太亮或太暗。</li></ol></li><li><ol start="2"><li>金属度为了确认是不是金属最好保持是1或0。</li></ol></li><li><ol start="3"><li>specular保持0到1之间的灰度，而不是颜色。</li></ol></li><li><ol start="4"><li>最黑的常见物是碳（rgb：0.03），最白的是雪（rgb：0.9）。永远不会是纯白或纯黑。</li></ol></li><li><ol start="5"><li>vantablack是世界上最黑的黑（rgb：0.0045, roughness:1）</li></ol></li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/vantablack.png" alt="vantablack"></li></ul></li><li><strong>打灯前确保移除自动曝光</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/deactiveAutoExposure.png" alt="deactiveAutoExposure"></li><li><strong>放置chrome sphere和grey sphere</strong><br> <img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/chromeSphere.png" alt="chromeSphere"><br> 保证它是纯反射物</li><li><strong>设置一个3.14（pi）的 directional light，并且用color picker 查看灰度</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/50%Grey.png" alt="50%Grey"></li></ol><hr><h2 id="🚩【四：烘培灯光-VS-动态灯光】"><a href="#🚩【四：烘培灯光-VS-动态灯光】" class="headerlink" title="🚩【四：烘培灯光 VS 动态灯光】"></a>🚩【四：烘培灯光 VS 动态灯光】</h2><h3 id="🥕Baked-Lighting："><a href="#🥕Baked-Lighting：" class="headerlink" title="🥕Baked Lighting："></a>🥕Baked Lighting：</h3><h4 id="🤓优势："><a href="#🤓优势：" class="headerlink" title="🤓优势："></a>🤓优势：</h4><ol><li>GI</li><li>cheap soft shadows，陈本低的阴影</li><li>Less GPU demanding，较低的GPU需求</li></ol><h4 id="😈劣势："><a href="#😈劣势：" class="headerlink" title="😈劣势："></a>😈劣势：</h4><ol><li>slower iteration，迭代变慢</li><li>static lighting，是静态的，如果生成更多的资产则新资产不会对照明产生影响</li><li>more maps in memory，需要储存空间来放light maps</li></ol><h3 id="🥕Dynamic-Lighting："><a href="#🥕Dynamic-Lighting：" class="headerlink" title="🥕Dynamic Lighting："></a>🥕Dynamic Lighting：</h3><h4 id="🤓优势：-1"><a href="#🤓优势：-1" class="headerlink" title="🤓优势："></a>🤓优势：</h4><ol><li>what u see is what u get，所见及所得</li><li>非静态的</li></ol><h4 id="😈劣势：-1"><a href="#😈劣势：-1" class="headerlink" title="😈劣势："></a>😈劣势：</h4><ol><li>No GI</li><li>GPU demanding，对GPU有要求</li></ol><hr><h2 id="🚩【五：常用烘培灯光设置】"><a href="#🚩【五：常用烘培灯光设置】" class="headerlink" title="🚩【五：常用烘培灯光设置】"></a>🚩【五：常用烘培灯光设置】</h2><h3 id="基础灯光设置："><a href="#基础灯光设置：" class="headerlink" title="基础灯光设置："></a>基础灯光设置：</h3><ol><li>Direction Light（Stationary）</li><li>Lightmass Baking（GI）</li><li>Skydome（static）</li></ol><h3 id="什么是light-map？"><a href="#什么是light-map？" class="headerlink" title="什么是light map？"></a>什么是light map？</h3><ul><li>light maps以纹理贴图的形式储存了灯光信息</li><li>它是HDR tecture并且储存了灯光方向</li><li>它的好处是处理起来很快，阴影柔和，但是如果文件太小则会缺少阴影的细节清晰度。</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lightasset2.png" alt="lightasset2"></li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lightasset.png" alt="lightasset"></li><li>min lightmap resolution将定义UV islands（padding）之间的空间</li><li>更小的padding会减少像素的浪费以及在相同的分辨率下得到更好的阴影效果</li></ul><hr><h3 id="Lighting-Type："><a href="#Lighting-Type：" class="headerlink" title="Lighting Type："></a>Lighting Type：</h3><ul><li>当烘培灯光时，一般只会使用static light（静态光） 或者是 stationary light（固定光）</li><li>emit photons：<ul><li>Directional light</li><li>point light</li><li>spot light</li></ul></li><li>emit no photon：<ul><li>sky light</li></ul></li></ul><hr><h3 id="Lightmass-Setting："><a href="#Lightmass-Setting：" class="headerlink" title="Lightmass Setting："></a>Lightmass Setting：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lightmass.png" alt="lightmass"></p><ul><li>static Lighting Level Scale * Indirect Lighting Quality &#x3D; 1.0;</li></ul><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lightmass_chart.png" alt="lightmass_chart"></p><ul><li>间接照明质量是最影响时长的</li></ul><hr><ul><li><strong>volume light sample scale</strong><ul><li>降低static lighting level scale会增加volume lighting samples的数量</li></ul></li><li><strong>lightmass Portal</strong><ul><li>对门窗类型的照明十分有用</li></ul></li><li><strong>lighting Scenarios</strong><ul><li>只用编辑一个enviroment level</li><li>照明方案会以light maps的形式分别储存</li><li>一个时间使用一个照明方案（不存在过渡，不能同时拥有两种在一个场景）</li></ul></li></ul><hr><h2 id="🚩【六：常用动态照明设置】"><a href="#🚩【六：常用动态照明设置】" class="headerlink" title="🚩【六：常用动态照明设置】"></a>🚩【六：常用动态照明设置】</h2><h3 id="基础灯光设置：-1"><a href="#基础灯光设置：-1" class="headerlink" title="基础灯光设置："></a>基础灯光设置：</h3><ol><li>Direction Light（movable）</li><li>SKydome（moveable）</li><li>Distance Field AO</li><li>Screen Space AO</li></ol><h3 id="什么是Distance-Field："><a href="#什么是Distance-Field：" class="headerlink" title="什么是Distance Field："></a>什么是Distance Field：</h3><ul><li>Distance Field 储存了每个点到最近表面的距离</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/distanceField.png" alt="distanceField"></li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/df_setup.png" alt="df_setup"></li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/dfao.png" alt="dfao"></li><li>需要避免过多的缩放</li><li>很大的物体对于distance field 的支持不理想，需要拆分成较小的部分</li></ul><h2 id="🚩【七：图像基础的照明-IBL】"><a href="#🚩【七：图像基础的照明-IBL】" class="headerlink" title="🚩【七：图像基础的照明 IBL】"></a>🚩【七：图像基础的照明 IBL】</h2><h3 id="基础灯光设置：-2"><a href="#基础灯光设置：-2" class="headerlink" title="基础灯光设置："></a>基础灯光设置：</h3><ul><li>设置场景，确保有一个平面可以投射并接受阴影</li><li>有一个back plate（需要制作跟踪）（可以理解为UE里做nuke的事情）</li><li>Directional light（moveable）</li><li>Skylight with HDRI（moveable）</li><li>fake steps shadow</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/backPlate.png" alt="backPlate"></li><li>当人走向光照位置则激活阴影</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/IBL.png" alt="IBL"></li></ul><hr><h2 id="🚩【八：shadow-maps，for-Dynamic-Shadowing】"><a href="#🚩【八：shadow-maps，for-Dynamic-Shadowing】" class="headerlink" title="🚩【八：shadow maps，for Dynamic Shadowing】"></a>🚩【八：shadow maps，for Dynamic Shadowing】</h2><ul><li>Depth map，判断存在阴影的部分</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/depthMap.png" alt="depthMap"></li><li>如果shadow map质量太低会有锯齿</li><li>如果shadow map bias太高则会有漏光</li><li>使用相机视锥来优化场景，近景给予更多的资源</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/camFrustum.png" alt="camFrustum"></li></ul><hr><h2 id="🚩【九：Directional-Light-Stationary-area-shadows：】"><a href="#🚩【九：Directional-Light-Stationary-area-shadows：】" class="headerlink" title="🚩【九：Directional Light Stationary area shadows：】"></a>🚩【九：Directional Light Stationary area shadows：】</h2><ul><li>激活Lightmass下的：use Area Shadows for Stationary Light</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/areaShadow.png" alt="areaShadow"></li></ul><hr><h2 id="🚩【十：capsule-shadows：】"><a href="#🚩【十：capsule-shadows：】" class="headerlink" title="🚩【十：capsule shadows：】"></a>🚩【十：capsule shadows：】</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/capsuleshadows.png" alt="capsuleshadows"></p><ul><li>使用一个类似资产的外轮廓来创建一个十分柔和的阴影</li></ul><hr><h2 id="🚩【十一：Raytraced-contact-shadows：】"><a href="#🚩【十一：Raytraced-contact-shadows：】" class="headerlink" title="🚩【十一：Raytraced contact shadows：】"></a>🚩【十一：Raytraced contact shadows：】</h2><ul><li>将contact shadow length 设置的很小来获得细节上的阴影</li><li>在比例很小的物体上很有用，但是比较耗费资源</li></ul><hr><h2 id="🚩【十二：Reflections：】"><a href="#🚩【十二：Reflections：】" class="headerlink" title="🚩【十二：Reflections：】"></a>🚩【十二：Reflections：】</h2><ul><li>反射较为资源</li><li>使用planer reflection来得到平面的反射（本质是在镜像它），平面的物体适用，但此不适用于有机形状。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;🍊这篇是UE的灯光与烘培的学习笔记，不大全面，有问题请随时指正🍊&lt;/strong&gt;&lt;br&gt;🍊这里是b站&lt;a href=&quot;https://www.bilibili.com/video/BV17K4y1L7Gf/?spm_id_from=333.788.r</summary>
      
    
    
    
    <category term="-UE4" scheme="http://example.com/categories/UE4/"/>
    
    
    <category term="-灯光" scheme="http://example.com/tags/%E7%81%AF%E5%85%89/"/>
    
  </entry>
  
  <entry>
    <title>UE4官方材质课_基础篇</title>
    <link href="http://example.com/2022/09/13/ue_MatClass_foundation/"/>
    <id>http://example.com/2022/09/13/ue_MatClass_foundation/</id>
    <published>2022-09-13T10:32:14.000Z</published>
    <updated>2022-09-23T08:42:40.788Z</updated>
    
    <content type="html"><![CDATA[<p>🐸本文为虚幻官方材质课的学习记录，并不完全，在此按我的个人需求记录了如下笔记。<strong>这一篇是基础篇</strong>。<br>🐸这里是基础篇<a href="https://www.bilibili.com/video/BV1fX4y1N7Fw?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接</a><br>🐸这里是高级篇<a href="https://www.bilibili.com/video/BV1sy4y127HZ/?spm_id_from=333.788.video.desc.click&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接</a><br>🐸<strong>加油 ！ 加油 ！</strong></p><hr><h1 id="UE4官方材质课-基础篇"><a href="#UE4官方材质课-基础篇" class="headerlink" title="UE4官方材质课_基础篇"></a>UE4官方材质课_基础篇</h1><h2 id="一：了解材质："><a href="#一：了解材质：" class="headerlink" title="一：了解材质："></a>一：了解材质：</h2><h3 id="🚩PBR（Physically-Based-Rendering）："><a href="#🚩PBR（Physically-Based-Rendering）：" class="headerlink" title="🚩PBR（Physically-Based Rendering）："></a>🚩PBR（Physically-Based Rendering）：</h3><p>基于物理的渲染。<br>它提供了一种光照和渲染方法，能够更精确的描绘光和表面之间的作用。<br>PBR流程能更真实的模拟光照和材质之间的物理交互效果。</p><ul><li>直观便于理解</li><li>物理上更具准确性<ul><li>pbr基于物理定律，如能量守恒定律和平方反比定律(Inverse-square law)</li><li>pbr材质在不同的光照下会表现的更一致</li></ul></li><li>使用真实的物理测量单位表示亮度<ul><li>Lumens(流明),Lux（勒克斯）</li></ul></li></ul><p>💡简单来说基于物理的渲染本质上是通过：</p><ul><li>材质</li><li>灯光</li><li>曝光</li></ul><p>这三大部分控制的组合结果。</p><h3 id="🚩Primary-PBR-Inputs："><a href="#🚩Primary-PBR-Inputs：" class="headerlink" title="🚩Primary PBR Inputs："></a>🚩Primary PBR Inputs：</h3><ul><li>Base col</li><li>Metallic</li><li>Specular</li><li>Roughness</li></ul><h4 id="🏕️Base-color（Albedo）"><a href="#🏕️Base-color（Albedo）" class="headerlink" title="🏕️Base color（Albedo）"></a>🏕️Base color（Albedo）</h4><ul><li>flat color,没有任何光照信息（没有高光和阴影）</li><li>只保存颜色信息</li><li>可以是linear RGB，也可也是一个Vector3</li><li>各个通道的数值位于0到1之间（纯白和纯黑会导致一些场景的曝光问题）</li></ul><h4 id="🏕️Metalic"><a href="#🏕️Metalic" class="headerlink" title="🏕️Metalic"></a>🏕️Metalic</h4><ul><li>Gray scale</li><li>数值在0 到 1的区间,不包含任何色彩信息</li><li>金属最正确的设置方式是全开或全关<ul><li>数值为0时，材质底色是diffuse</li><li>数值为1时，材质底色是specular&#x2F;reflection color</li><li>示例图：<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/metallic.png" alt="metallic"></li></ul></li></ul><h4 id="🏕️Roughness"><a href="#🏕️Roughness" class="headerlink" title="🏕️Roughness"></a>🏕️Roughness</h4><ul><li>Gray scale</li><li>数值在0 到 1的区间,不包含任何色彩信息<ul><li>数值为0时，无限接近于镜面反射</li><li>数值为1时，为粗糙表面</li></ul></li></ul><p>粗糙度是能量守恒的体现。</p><h4 id="🏕️Specular"><a href="#🏕️Specular" class="headerlink" title="🏕️Specular"></a>🏕️Specular</h4><ul><li>控制高光和反射（specular highlights and reflections）</li><li>Gray scale</li><li>一般情况下保持default value 0.5就可以了</li><li>通常情况下，我们通过调整Roughness来调整高光质感</li><li>正常世界中，所有物体都有一定程度的反射和高光效果</li></ul><p>示例图：<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/roughness.png" alt="roughness"></p><h3 id="🚩UE支持的图片文件的格式（常用）："><a href="#🚩UE支持的图片文件的格式（常用）：" class="headerlink" title="🚩UE支持的图片文件的格式（常用）："></a>🚩UE支持的图片文件的格式（常用）：</h3><table><thead><tr><th>未压缩格式</th><th>压缩格式</th></tr></thead><tbody><tr><td>BMP</td><td>PNG（simple Alpha）</td></tr><tr><td>TGA（Alpha）</td><td>JPG</td></tr><tr><td>PSD</td><td>DDS</td></tr><tr><td></td><td>HDR</td></tr></tbody></table><ul><li>simple Alpha通常被用于植被</li></ul><h3 id="🚩贴图规则："><a href="#🚩贴图规则：" class="headerlink" title="🚩贴图规则："></a>🚩贴图规则：</h3><ul><li>最大支持8k</li><li>长宽必须是2的指数幂（512，1024，2048）</li><li>roughness，metallic，specular均不需要rgb通道，所以直接储存为gray scale导入UE。这样他们就会被自动设置成灰度图，并且不会启动sRGB或者Linear的颜色空间</li><li>Normal 贴图也同理，不需要使用sRGB</li><li>HDR 也不需要使用sRGB，因为它的取值一般会超出范围</li><li>sRGB只适用于颜色贴图（导入需要确保灰度图没有勾选sRGB）</li><li>所有的灰度贴图只要储存形式正确，那么UE会直接自动设置为禁用sRGB</li><li>所有的base col应当将压缩格式设置为DXT1（在贴图设置选项中，compression也可以自行更改，如果格式正确，那么UE会自动为你设置好它的compression setting）</li></ul><h3 id="🚩贴图导入方式："><a href="#🚩贴图导入方式：" class="headerlink" title="🚩贴图导入方式："></a>🚩贴图导入方式：</h3><ul><li>直接拖入项目</li><li>右键在content browser选择import Assets</li></ul><h3 id="🚩UE材质编辑器tips："><a href="#🚩UE材质编辑器tips：" class="headerlink" title="🚩UE材质编辑器tips："></a>🚩UE材质编辑器tips：</h3><ul><li>双击节点之间的连线，创建dot整理节点</li><li>c，创建comment</li><li>ctl+拖动节点连线来改变节点连接输出的位置</li><li>clean up删除此节点图中的孤立节点（unused node）</li><li>connector改变节点显示方式</li><li>T，创建texture sample</li></ul><h3 id="🚩混合模式："><a href="#🚩混合模式：" class="headerlink" title="🚩混合模式："></a>🚩混合模式：</h3><p>在Material中，可以找到<strong>Blend Mode</strong>和<strong>Shading Mode</strong>这两项，这两项十分重要</p><h4 id="🍭Blend-Mode："><a href="#🍭Blend-Mode：" class="headerlink" title="🍭Blend Mode："></a>🍭Blend Mode：</h4><ul><li><strong>Opaque 不透明</strong><ul><li>多数不透明材质的基本设置</li></ul></li><li><strong>masked 遮罩</strong><ul><li>显示有mask遮罩的材质</li><li>背面默认不显示，需要开启two sided</li></ul></li><li><strong>Translucent 半透明</strong><ul><li>通常使用在半透明材质，玻璃等有折射的材质</li><li>同时控制opacity与refraction来调整效果</li><li>Translucent一般情况下以最简单的方式计算半透明，以节约开销</li><li>如果想提升半透明材质的效果，需要来到Translucency的选项下，勾选Screen SPace Reflection，并把Lighting Mode改成Surface ForwardShading；这两个选项能让我们获得最高质量的半透明材质。开启这两个选项后，着色器需要更长的时间编译。</li></ul></li><li><strong>additive 叠加</strong></li><li><strong>Modulate 调制</strong></li><li><strong>AlphaComposite（Premultiplied Alpha） alpha复合（预乘Alpha）</strong></li></ul><p><strong>Translucent：</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/blendMode_Translucent.png" alt="blendMode_Translucent"></p><h4 id="🍭Shading-Mode："><a href="#🍭Shading-Mode：" class="headerlink" title="🍭Shading Mode："></a>🍭Shading Mode：</h4><ul><li><strong>Default Lit</strong><ul><li>通常的光照设置，材质受光照影响</li></ul></li><li><strong>Unlit</strong><ul><li>材质不受光照影响；这种模式下允许表面产生自发光</li></ul></li><li><strong>subsurface</strong><ul><li>次表面散射，如皮肤和蜡烛</li></ul></li><li><strong>clear coat</strong></li><li><strong>two sided foliage</strong></li><li><strong>hair</strong></li><li><strong>cloth</strong></li><li><strong>eye</strong></li></ul><h5 id="🍌subsurface-scattering"><a href="#🍌subsurface-scattering" class="headerlink" title="🍌subsurface scattering"></a>🍌subsurface scattering</h5><ul><li>将Material的shading mode设置为subsurface</li><li>主要使用两个矢量（base color和subsurface color）和两个标量（opacity和roughness）</li></ul><p>示例：<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/subsurfaceMat.png" alt="subsurfaceMat"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/subsurface.png" alt="subsurface"></p><h3 id="🚩创建一个简单材质："><a href="#🚩创建一个简单材质：" class="headerlink" title="🚩创建一个简单材质："></a>🚩创建一个简单材质：</h3><ul><li>当我们给mesh更换材质，或应用新材质时，需要在静态网格编辑器（Static Mesh Editor）中打开mesh，并且在右侧Detail面板下更换指定新材质</li><li>UE支持多材质对象。一个mesh可以有多个elements并指定材质</li><li>最好遵从材质命名规则，如Material最好以<strong>M_name</strong>这样以M为前缀来开头</li><li>T for texture sample，选择我们需要的贴图</li><li>基础材质创建使用的大多数是：base col， roughness， normal</li></ul><h3 id="🚩继续简单材质："><a href="#🚩继续简单材质：" class="headerlink" title="🚩继续简单材质："></a>🚩继续简单材质：</h3><ul><li><p>如果希望在贴图中预览并使用到UE的content，则需要再texture的选项里打开<strong>show Engine Content</strong></p><ul><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/showUEcontent.png" alt="showUEcontent"></li></ul></li><li><p><strong>反转黑白可以使用（1-x）One Minus</strong></p></li><li><p><strong>混合：Multiply（M）</strong></p></li><li><p><strong>相加：Add（A</strong>）</p></li><li><p>使用constant与贴图Multiply，以达到控制灰度的效果，或使贴图与相应选区进行混合</p></li><li><p><strong>常用噪波：perlin noise</strong></p></li><li><p><strong>线性插值：Lerp</strong></p><ul><li>利用alpha通道混合a，b两个图层</li></ul></li><li><p><strong>常用扁平法线：flatnormal</strong></p></li><li><p><strong>平铺纹理：Texture Coordinate</strong></p></li></ul><h3 id="🚩使用DataSmith从其他DCC软件导入材质到UE："><a href="#🚩使用DataSmith从其他DCC软件导入材质到UE：" class="headerlink" title="🚩使用DataSmith从其他DCC软件导入材质到UE："></a>🚩使用DataSmith从其他DCC软件导入材质到UE：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/vraytoUE_datasmith.png" alt="vraytoUE_datasmith"><br>简单解释就是其他的软件制作好的材质会被以一种datasmith提供的方式转换到ue中，但是有些情况下是无法正确转换的。需要额外自行修正，并且灯光也不会被预先烘培。</p><hr><h2 id="二：创建PBR材质（基础）"><a href="#二：创建PBR材质（基础）" class="headerlink" title="二：创建PBR材质（基础）"></a>二：创建PBR材质（基础）</h2><h3 id="🚩主材质实例："><a href="#🚩主材质实例：" class="headerlink" title="🚩主材质实例："></a>🚩主材质实例：</h3><ul><li>实例化材质可以为我们的主材质创建副本，然后用来代替主材在项目中使用</li><li>实例化材质的优点：<br>  1.节约时间，可以通过公开主材质的某些参数，进一步调整实例材质而无需重新编译着色器。<br>  2.对主材质进行的改动也会更新到所有的材质实例。<br>  3.仅需要根据材质特性创建主材质，然后实例化材质应用到所有的类似材质上。</li></ul><h3 id="🚩公开材质参数："><a href="#🚩公开材质参数：" class="headerlink" title="🚩公开材质参数："></a>🚩公开材质参数：</h3><ul><li>右键相应节点，convert to parameter并重命名</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/convertParam.png" alt="convertParam"></li></ul><h3 id="🚩switch："><a href="#🚩switch：" class="headerlink" title="🚩switch："></a>🚩switch：</h3><ul><li><strong>Static Switch Parameter</strong>，静态开关参数</li><li>使我们开启或禁用某些功能<br><strong>示例：</strong><br>当True的时候，开启base color与纯色相乘，为False时则关闭相乘，仅显示base color<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/swichPara.png" alt="swichPara"></li></ul><h3 id="🚩实例材质的优先级以及参数最大最小值："><a href="#🚩实例材质的优先级以及参数最大最小值：" class="headerlink" title="🚩实例材质的优先级以及参数最大最小值："></a>🚩实例材质的优先级以及参数最大最小值：</h3><p><strong>当制作材质的时候，可以修改材质参数的优先级方便使用</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/groupandpior.png" alt="groupandpior"><br><strong>我们可以通过修改Group和sort Piriority来实现</strong></p><ul><li>只需要选中group中的“None”，将None改为我们需要的组名</li><li>sort Piriority为0的组会优先出现再我们的分组中，依次是1，2，3的组</li><li>分组需要按需求比如tex，utility，uv之类的功能不同的节点可以分开设置，并自行定义优先级</li></ul><p><strong>示例：</strong> 此时所有的参数就被归档在我们定义好的组中。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/groupPreview.png" alt="groupPreview"></p><p><strong>✏️可以给参数滑块设置最大最小值，使可以调节的范围不超过我们设定的值</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/minMax.png" alt="minMax"></p><h3 id="🚩动态材质："><a href="#🚩动态材质：" class="headerlink" title="🚩动态材质："></a>🚩动态材质：</h3><p><strong>材质一般在UE中分为两种：</strong></p><ol><li>静态材质</li><li>动态材质<ul><li>动态材质让我们在运行的时候实时调整</li></ul></li></ol><p><strong>Actor：</strong></p><ul><li>Actor与普通的mesh相比，它可以附加蓝图</li><li>我们需要在Event Graph中创建我们的功能</li><li>创建dynamic material，并在source Material中指定材质源</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/bpshaderball.png" alt="bpshaderball"></li><li>之后再set texture parameter value ，使用我们指定的参数Diffuse</li><li>再创建set scalar Parameter value， 控制Metallic</li><li>最后需要set vector parameter value，设置Color</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/bpshaderball2.png" alt="bpshaderball2"></li><li>因为我们或许希望color不会在创建出的时候即刻执行，我们希望用户再点击屏幕对象的时候改变这个参数，所以此时还需要“事件调度器（Event Dispatchers）”来完成它</li><li>此时需要先创建变量，再set color</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/bpvriable.png" alt="bpvriable"></li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/bpvriableType.png" alt="bpvriableType"></li><li>最后设置event Dispatchers，选择event。最后compile，此时编辑好了actor的材质。</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/bpeventDisp2.png" alt="bpeventDisp2"></li></ul><h3 id="🚩编辑level-Blueprint："><a href="#🚩编辑level-Blueprint：" class="headerlink" title="🚩编辑level Blueprint："></a>🚩编辑level Blueprint：</h3><ul><li>现在要做事情使编辑关卡的蓝图，使我们之前编辑的actor生效，效果达到：点击之前编辑的actor，并使它颜色发生改变</li><li>进入level BP，创建get player controller，获取用户的动态，mouse cursor，click even看他是否对actor进行操作，然后再用事件调度器触发自定义事件</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lbp_clickeven.png" alt="lbp_clickeven"></li><li>接着我们要判断用户是否点击到了正确的对象 ，然后再触发自定义事件，完成颜色替换的指令</li><li>get hit result under cursor for object，然后确认object type，使用make Array，确认我们希望用户能够点击哪类对象。</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lbp_clickeven2.png" alt="lbp_clickeven2"></li><li>接着left mouse button获取鼠标的动态，看右键是否点击到了正确的目标。</li><li>get class，class is child of，得到父类下正确的对象。如果结果是我们需要的对象，则返回True。</li><li>cast to ，通过这个引用我们可以访问之前用于改变颜色的自定义事件。</li><li>最后获取change color even，获取到我们之前定义的事件，并且设置随机颜色。</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lbp_clickeven3.png" alt="lbp_clickeven3"></li><li>compile，play。这样我们自定义的actor就会随着鼠标点击随机改变颜色。</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lbp_clickeven4.png" alt="lbp_clickeven4"></li></ul><h3 id="🚩材质参数集合，创建全局参数集（Parameter-Collection）："><a href="#🚩材质参数集合，创建全局参数集（Parameter-Collection）：" class="headerlink" title="🚩材质参数集合，创建全局参数集（Parameter Collection）："></a>🚩材质参数集合，创建全局参数集（Parameter Collection）：</h3><ul><li>有时候因为场景变化的需求，比如下雨天材质整体变得湿润，或者受到风力影响而相关材质摇曳的程度增强，或者自发光强度因为场景变化需要整体变强。</li><li>如果一个一个调整则很花费时间。此时就要用到材质参数集，达到批量修改整体参数的目的。</li><li>我们可以右键在content中创建Meterial Parameter Collection，再分别创建自己需要的全局标量和向量。</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/mpc_setting.png" alt="mpc_setting"></li><li>在Master Mat中，建立collection parameter，选择之前创建的参数集，与需要修改的参数相乘。</li><li>如有float4的参数出现，则需要使用component Mask转换成float3，以免出现数据类型的不匹配</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/mpc_setting2.png" alt="mpc_setting2"></li><li><strong>全局参数集相当于给所有设置全局变量的参数一个总控制，每个单独的材质也可以在自己的材质球下独立调节，但是总集控制所有材质的全局参数，如果在总集禁用，那么独立的材质的那个参数也会被禁用。</strong></li></ul><h3 id="🚩材质参数集合，第二部分："><a href="#🚩材质参数集合，第二部分：" class="headerlink" title="🚩材质参数集合，第二部分："></a>🚩材质参数集合，第二部分：</h3><ul><li>现在想要实现：允许用户点击后，更改其中的一个全局参数</li><li>需要在level BluePrint里进行编辑，与Actor部分相似，前半部分判断鼠标点击以及获取用户行为的蓝图操作是一样的（在我的基础篇笔记上篇）</li><li>之后，判断点击对象，确保在视窗内选中正确对象然后 create reference带入蓝图</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/mpc__bpsetting.png" alt="mpc__bpsetting"></li><li>选择正确的目标进行判断，并设置好rendom vector。</li><li>compiled，此时play就会看见随着鼠标点击，全局对象也可以随机改变颜色了。</li></ul><h3 id="🚩材质函数："><a href="#🚩材质函数：" class="headerlink" title="🚩材质函数："></a>🚩材质函数：</h3><ul><li>材质函数就是材质图表中可以反复使用的自定义代码片段</li><li>它的好处是可以把复杂的材质图表转化成拥有单个输入输出的单个材质节点</li><li>更改代码中的函数，所有实例也会同步修改</li></ul><h4 id="✏️此时的案例要实现的是uv-tiling。"><a href="#✏️此时的案例要实现的是uv-tiling。" class="headerlink" title="✏️此时的案例要实现的是uv tiling。"></a>✏️此时的案例要实现的是uv tiling。</h4><ul><li>在content中创建Material Function，点击进去。</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_func01.png" alt="m_func01"></li><li>如上图，我们首先设置uv 平铺，其次设置旋转，再判断使用不使用rotation</li><li>编辑好后需要单击面板，开启左侧列表中的“Expose to Library”，才能确保我们后续能正常搜索到它。</li><li>接下来回到我们需要使用tiling的材质</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_func01_tiling.png" alt="m_func01_tiling"></li><li>搜索我们之前创建的Function，并根据我们之前设置的变量来分别连接参数</li><li>此时这个材质就有UV Tiling的选项。</li></ul><p><strong>数据迁移：</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_func_Migrate.png" alt="m_func_Migrate"></p><ul><li>此方式能够将做好的材质函数迁移到其他文件使用</li><li>当然也可以通过这种方式迁移别的需要的资产</li></ul><h4 id="✏️另一种材质函数的方式：CustomNode"><a href="#✏️另一种材质函数的方式：CustomNode" class="headerlink" title="✏️另一种材质函数的方式：CustomNode"></a>✏️另一种材质函数的方式：CustomNode</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_customNode.png" alt="m_customNode"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_customN_name.png" alt="m_customN_name"></p><ul><li>这种方式通过hlsl语言来创建材质函数，得到自制的材质节点</li><li>设置的input name需要与code的名字匹配</li><li>定义hlsl并不像内置的材质表达式，且无法被优化</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_customN.png" alt="m_customN"></li></ul><hr><h2 id="三：实例创建不同的材质演示："><a href="#三：实例创建不同的材质演示：" class="headerlink" title="三：实例创建不同的材质演示："></a>三：实例创建不同的材质演示：</h2><h3 id="🚩clear-coat制作类似车漆质感："><a href="#🚩clear-coat制作类似车漆质感：" class="headerlink" title="🚩clear coat制作类似车漆质感："></a>🚩clear coat制作类似车漆质感：</h3><ul><li>将shading mode设置为clear coat后，Material会又clear coat和clear coat Roughness这两个选项</li><li>它的显示方式与普通的材质较为相似，如果希望有光滑的表面，并且希望透明图层下的表面有凹凸效果，就可以选择clear coat来模拟</li><li>如果要启用clear coat的第二层normal，则需要去setting中开启（默认是关闭的）</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/clearcoat_enableSecNormal.png" alt="clearcoat_enableSecNormal"></li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/btNormal.png" alt="btNormal"></li><li>我们可以lerp两个scaler控制roughness，并用类似的方式控制设置表面的normal以及clear coat光滑表面下的bottom normal</li><li><strong>示例：</strong></li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/clearcoatmat.png" alt="clearcoatmat"></li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/clearcoatmat_view.png" alt="clearcoatmat_view"></li></ul><h3 id="🚩Two-Sided-Foliage-双面植被："><a href="#🚩Two-Sided-Foliage-双面植被：" class="headerlink" title="🚩Two-Sided Foliage 双面植被："></a>🚩Two-Sided Foliage 双面植被：</h3><ul><li>masked这种模式需要与shading mode下双面材质（two sided foliage）设置配合使用。（如果是default lit的模式下，则没有subsurface通道）</li><li>这种着色方式实际上并不是半透明的，但他能很好的与蒙版混合模式搭配使用，并且借助subsurface color以更低的开销模拟半透明效果。</li><li>其他的材质通道设置与普通材质没有很大区别,要注意的是使用opacity mask并且需要双面显示的话，一定要勾上two sided这个选项。</li><li>借助wo Sided Texturing这个function可以分开控制双面材质正反两面的参数以及效果，最终的结果就是调节了subsurface以模拟光透过叶片的效果</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/twoSidedFunction.png" alt="twoSidedFunction"></li><li><strong>示例：</strong></li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/twoSidedFoliage.png" alt="twoSidedFoliage"></li></ul><h3 id="🚩布料着色："><a href="#🚩布料着色：" class="headerlink" title="🚩布料着色："></a>🚩布料着色：</h3><blockquote><p><strong>小tip</strong>：如果有时候近处被裁切影响放大观察，则可以去Output Log的cmd中输入：r.SetNearClipPlane 1,将相机近景裁切更改为1</p></blockquote><ul><li>通常我们可以使用subsurface或者fresnel来实现布料的模拟。但是UE提供的 shading mode下就有 cloth这个选项，该着色模式使模拟布料的时候可以用于不同角度查看它的毛绒质感</li><li>我们创建布料材质的时候，shading mode需要选择cloth，blend mode保持opaque；此时Material中就会有Fuzz color 和cloth这两个通道。cloth通道可以借助mask指定该材质哪些部分是布料。如果是窗帘这样需要双面的材质，则也需要勾选two sided。</li><li>可以通过两个texture sample将布料纹理和布料图案分开设置，同理也可以将roughness和normal用一样的方式分开设置。</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_cloth_basecol.png" alt="m_cloth_basecol"></li><li>blend angle corrected normal，这个内置函数可以混合两张法线贴图</li><li><strong>FuzzyShading</strong>，此函数可以使用于fuzz color，它支持我们控制菲涅尔</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_cloth_basecol.png" alt="m_cloth_basecol"></li><li>我们通过调节这些参数的组合得到不同的效果</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_cloth_display.png" alt="m_cloth_display"></li></ul><h3 id="🚩染色玻璃："><a href="#🚩染色玻璃：" class="headerlink" title="🚩染色玻璃："></a>🚩染色玻璃：</h3><p><strong>方案步骤：</strong></p><ol><li>使用顶点色，来打造有色玻璃的效果，并且玻璃的着色颜色仅显示在最厚的部分</li><li>使用UE中的内置函数，给玻璃表面添加磨砂或者模糊效果</li></ol><h4 id="🐢第一部分：创建基础玻璃"><a href="#🐢第一部分：创建基础玻璃" class="headerlink" title="🐢第一部分：创建基础玻璃"></a>🐢<strong>第一部分：创建基础玻璃</strong></h4><ul><li>创建material，使用blendMode为 Translucent，shading mode保持Default Lit。</li><li>随后去到Translucency的选项下，lighting Mode选择使用Surface ForwardShading或者Surface TranslucencyVolume，开启质量较高的着色选项。开启后可以发现material可以使用metallic，roughness等通道了。</li><li>设置一个简单的折射控制，使用fresnel作为Lerp，alpha来设置边缘到中心的折射参数。玻璃的IOR差不多设置在1.2-1.52之间。</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_refraction.png" alt="m_glass_refraction"></li></ul><h4 id="🐢第二部分：加上玻璃边缘的磨砂绿色质感"><a href="#🐢第二部分：加上玻璃边缘的磨砂绿色质感" class="headerlink" title="🐢第二部分：加上玻璃边缘的磨砂绿色质感"></a>🐢<strong>第二部分：加上玻璃边缘的磨砂绿色质感</strong></h4><ul><li>这一部分使用Modes中的paint来绘制顶点色实现</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_vertexCol.png" alt="m_glass_vertexCol"></li><li>我们仅仅需要影响桌子的边缘，再将绘制好的顶点信息导入材质，以确定哪些区域被采用并进行上色。绘制完成后记得保存此vertex color到内容浏览器中。</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_vertexColBlend.png" alt="m_glass_vertexColBlend"></li><li>添加使用vertex color</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_vertexColBlend2.png" alt="m_glass_vertexColBlend2"></li></ul><h4 id="🐢第三部分：使用菲涅尔改进色调真实度"><a href="#🐢第三部分：使用菲涅尔改进色调真实度" class="headerlink" title="🐢第三部分：使用菲涅尔改进色调真实度"></a>🐢<strong>第三部分：使用菲涅尔改进色调真实度</strong></h4><ul><li>使用Fresnel_Function，使玻璃内部和外部可以分开调节</li><li>使用Pixel NormalWS（像素法线世界空间）作为normal vector</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_Fresnel_Function2.png" alt="m_glass_Fresnel_Function2"></li><li>使用substract，设置玻璃的边缘透明度</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_edgeOpacity.png" alt="m_glass_edgeOpacity"></li><li>在视图窗口也可以使用Visual effect中的Planar Reflection来提升反射效果，得到更准确的反射（适用于平面，但不太适合其他有机形状）</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_table.png" alt="m_glass_table"></li></ul><h4 id="🐢第四部分：设置一些磨砂效果"><a href="#🐢第四部分：设置一些磨砂效果" class="headerlink" title="🐢第四部分：设置一些磨砂效果"></a>🐢<strong>第四部分：设置一些磨砂效果</strong></h4><ul><li>spiralBlur-SceneTexture，我们需要用这个自带函数来控制材质的自发光颜色，并需要与Opacity的边缘控制也关联</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_spirlblur.png" alt="m_glass_spirlblur"></li><li>现在我们需要反转之前绘制的vertex color再与spiralBlur相乘，来连接自发光颜色</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_spirlblur_emmisive.png" alt="m_glass_spirlblur_emmisive"></li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_frosted.png" alt="m_glass_frosted"></li><li>切记多调整参数来得到满意的效果</li></ul><h3 id="🚩置换贴图，模拟毛毯地毯一类："><a href="#🚩置换贴图，模拟毛毯地毯一类：" class="headerlink" title="🚩置换贴图，模拟毛毯地毯一类："></a>🚩置换贴图，模拟毛毯地毯一类：</h3><blockquote><p><strong>发布支持DX11显卡时，引入了一项全新的硬件功能：real-time Dynamic Tessellation Geometry。使我们能够使用置换纹理贴图在显卡上增加对象的多边形面数，由此显著提升了对象的物理细节而无需真正对此细节进行建模。</strong></p></blockquote><ul><li>创建materail的时候，需要先开启细分。去Tessellation的选项下，D3D11Tesselation中选择Flat Tesselation。还要勾选Crack Free Displacement，保留Adaptive Tessellation。</li><li>此时Material中有新增了两个通道：<ul><li>World Displacement（用于连接displacement Map）</li><li>Tessellation Multiplier（控制有多少polygon总数添加到对象，数量越大，置换效果越详细，但一般不建议开的很高）</li></ul></li><li>一般情况下，displacement map使用普通灰度图即可。</li><li>如果在displacement的数值很高的情况下，导致边缘会产生与主体分离的效果，可以使用绘制vertex color来绘制边缘的部分，让边缘的部分不受tessellation的影响来解决这一问题。</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20220917204344.png" alt="paintEdges"></li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_displacement.png" alt="m_displacement"></li><li>使用置换贴图必须先确保基础模型的网格数不会太低。</li><li>置换贴图也会对性能产生影响，所以要谨慎使用。</li></ul><h3 id="🚩顶点动画，创建窗帘随风吹动的效果："><a href="#🚩顶点动画，创建窗帘随风吹动的效果：" class="headerlink" title="🚩顶点动画，创建窗帘随风吹动的效果："></a>🚩顶点动画，创建窗帘随风吹动的效果：</h3><ul><li>了解“世界场景位置偏移”（World Position offset）</li><li>使用基本的material的设置创建布料材质作为基础，并使用World Position offset来创建窗帘的顶点动画</li><li>使用panner来加入动画，使用vertex color绘制需要动画的部分，并加入材质控制</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_vertexAni_graph1.png" alt="m_vertexAni_graph1"></li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_vertexAni_graph2.png" alt="m_vertexAni_graph2"></li><li>需要将这个模型对象设置为movable来获得正确的光照和阴影显示</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_vertexAni.png" alt="m_vertexAni"></li></ul><hr><p>终于刷完了！受益匪浅！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;🐸本文为虚幻官方材质课的学习记录，并不完全，在此按我的个人需求记录了如下笔记。&lt;strong&gt;这一篇是基础篇&lt;/strong&gt;。&lt;br&gt;🐸这里是基础篇&lt;a href=&quot;https://www.bilibili.com/video/BV1fX4y1N7Fw?spm_id_</summary>
      
    
    
    
    <category term="-UE4" scheme="http://example.com/categories/UE4/"/>
    
    
    <category term="-材质" scheme="http://example.com/tags/%E6%9D%90%E8%B4%A8/"/>
    
  </entry>
  
  <entry>
    <title>Houdini湖边小屋学习（一）</title>
    <link href="http://example.com/2022/09/13/houdini_lakeHouse_p1/"/>
    <id>http://example.com/2022/09/13/houdini_lakeHouse_p1/</id>
    <published>2022-09-13T10:09:03.000Z</published>
    <updated>2022-09-18T09:57:36.313Z</updated>
    
    <content type="html"><![CDATA[<p>🐸本文为我的houdini湖边小屋笔记第一篇内容，作为我PCG的进阶学习部分来记录一下~~~<br>🐸目前是<strong>第一篇</strong><br>🐸加油加油！</p><hr><h1 id="湖边小屋第一篇"><a href="#湖边小屋第一篇" class="headerlink" title="湖边小屋第一篇"></a>湖边小屋第一篇</h1><h2 id="第一部分-Base-shape："><a href="#第一部分-Base-shape：" class="headerlink" title="第一部分 Base shape："></a>第一部分 Base shape：</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;🐸本文为我的houdini湖边小屋笔记第一篇内容，作为我PCG的进阶学习部分来记录一下~~~&lt;br&gt;🐸目前是&lt;strong&gt;第一篇&lt;/strong&gt;&lt;br&gt;🐸加油加油！&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;湖边小屋第一篇&quot;&gt;&lt;a href=&quot;#湖边小屋第一篇&quot; clas</summary>
      
    
    
    
    <category term="-Houdini" scheme="http://example.com/categories/Houdini/"/>
    
    
    <category term="-PCG" scheme="http://example.com/tags/PCG/"/>
    
  </entry>
  
  <entry>
    <title>Houdini 中for-each 和for-loop 节点</title>
    <link href="http://example.com/2022/09/13/houdini_foreach/"/>
    <id>http://example.com/2022/09/13/houdini_foreach/</id>
    <published>2022-09-13T10:09:03.000Z</published>
    <updated>2022-09-23T09:46:17.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Houdini-中for-each-和for-loop-节点"><a href="#Houdini-中for-each-和for-loop-节点" class="headerlink" title="Houdini 中for-each 和for-loop 节点"></a>Houdini 中for-each 和for-loop 节点</h1><p>学习houdini时间不长，刚入门的时候就一直对foreach的使用比较迷糊，在这里写一篇学习笔记来认识一下这个使用方式，比较基础 。如果有问题，请各位大佬及时补充和指正！</p><hr><h2 id="Houdini中关于循环的节点简介："><a href="#Houdini中关于循环的节点简介：" class="headerlink" title="Houdini中关于循环的节点简介："></a>Houdini中关于循环的节点简介：</h2><p>houdini中一共给了这6个框架：<br><strong>1. for-each Number<br>2. for-each point<br>3. for-each primitive<br>4. for-each connected Piece<br>5. for-each Named Primitive<br>6. for-loop with Feedback</strong></p><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/foreach2.png" alt="foreach2"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/foreach1.png" alt="foreach1"><br>（在这里说明我用的是houdini 18之后的版本，如果版本太靠前应该foreach节点跟这个有所出入）</p><ul><li>这个框架它本身的作用就是实现for循环，如果不想用它的框架，也可以自己创建Block begin和Block end来搭建for循环。</li><li>其中，<strong>for-each point，for-each primitive，for-each connected Piece和for-each Named Primitive</strong>的构造是相似的，使用的方法也是一样的，只是针对的元素不同（点，面，name属性）</li><li><strong>connectivity</strong>是创造了一个class属性，根据class属性处理导入这个元素。</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20220921233222.png" alt="foreach2"></li><li>数据都是从Block Begin传入，我们中间可以任意添加节点来完成我们想要针对这个元素处理的操作，这个数据给每个元素循环处理后，最终由block end输出。end中可以选择Feedback Each Iteration来显示每一次结果，或者Merge Each Iteration来显示所有结果。</li></ul><h2 id="例子一：随机颜色："><a href="#例子一：随机颜色：" class="headerlink" title="例子一：随机颜色："></a>例子一：随机颜色：</h2><ul><li>针对<strong>for-each point，for-each primitive，for-each connected Piece和for-each Named Primitive</strong>这四个框架可以做出此示例。</li><li>循环迭代次数不是自动给出的，需要通过Block Begin中的“Create meta import Node来创建；它的detail上会有iteration的参数。若我们希望使用foreach，来达到进入循环的元素被进行的处理或者操作有所变化，那么我们也是通过iteration来实现的。</li></ul><h3 id="for-each-point："><a href="#for-each-point：" class="headerlink" title="for-each point："></a>for-each point：</h3><ul><li>使用vex做一个简单的颜色随机，注意iteration不要写错<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/foreach_randCol_pt.png" alt="foreach_randCol_pt"></li></ul><h3 id="for-each-primitive："><a href="#for-each-primitive：" class="headerlink" title="for-each primitive："></a>for-each primitive：</h3><ul><li>对于primitive也是完全一样的<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/foreach_randCol_prim.png" alt="foreach_randCol_prim"></li></ul><h3 id="for-each-connected-Piece："><a href="#for-each-connected-Piece：" class="headerlink" title="for-each connected Piece："></a>for-each connected Piece：</h3><ul><li>对于for-each connected Piece，则是根据它的class属性，处理它连续的元素。</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/foreach_randCol_connPiec.png" alt="foreach_randCol_class"></li></ul><h3 id="for-each-Named-Primitive："><a href="#for-each-Named-Primitive：" class="headerlink" title="for-each Named Primitive："></a>for-each Named Primitive：</h3><ul><li>for-each Named Primitive也是根据name属性来处理元素（属性是在piece attribute上的，可以更改，但必须保持输入输出的是一致的，否则不能匹配）</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/foreach_randCol_name.png" alt="foreach_randCol_name"></li></ul><h2 id="for-each-Number的用法："><a href="#for-each-Number的用法：" class="headerlink" title="for-each Number的用法："></a>for-each Number的用法：</h2><ul><li>可以看出，它的Block Beginn中的method变成了“Fetch Input”，它的Block end中 Iteration Method变为了“By Count”。 他并不是对每个元素进行处理，而是对他本身进行拷贝，进入循环，它的迭代次数就是它的拷贝次数。</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/foreach_number.png" alt="foreach_number"></li><li>由上示例，它每次的循环均为它的input，根据iteration的次数来做重复。</li></ul><h2 id="for-Loop的用法："><a href="#for-Loop的用法：" class="headerlink" title="for-Loop的用法："></a>for-Loop的用法：</h2><ul><li>for-loop with Feedback中，它的默认Block Beginn中的method是“Fetch FeedBack”，它的Block end中 Iteration Method是“By Count”；它的Gather Method则默认是Feedback Each Iteration。如果for-each Number是指对本身的元素进行处理，那么for-loop with Feedback就是对循环整体进行处理。</li><li>它是以上一个循环的end的结果作为下一次循环的起点，进行再次循环，一直循环操作我们在循环内设置的指令，直到迭代次数结束。</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/forLoop.png" alt="forLoop"></li><li>由上图示例，这个rubbertoy朝着x轴正向移动，每次移动单位为1米，循环了五次，移动到现在5米的位置。</li><li>下图是merge each iteration，显示每次循环结果，可以更清晰看出。</li><li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/forLoop_MergeEachIteration.png" alt="forLoop_MergeEachIteration"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Houdini-中for-each-和for-loop-节点&quot;&gt;&lt;a href=&quot;#Houdini-中for-each-和for-loop-节点&quot; class=&quot;headerlink&quot; title=&quot;Houdini 中for-each 和for-loop 节点&quot;&gt;</summary>
      
    
    
    
    <category term="-Houdini" scheme="http://example.com/categories/Houdini/"/>
    
    
    <category term="-Houdini节点" scheme="http://example.com/tags/Houdini%E8%8A%82%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Markdown基本语法</title>
    <link href="http://example.com/2022/09/13/markdown%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2022/09/13/markdown%E8%AF%AD%E6%B3%95/</id>
    <published>2022-09-13T04:30:03.000Z</published>
    <updated>2022-09-23T08:42:39.618Z</updated>
    
    <content type="html"><![CDATA[<h3 id="注明备忘：这里使用的编辑器是vscode，下载的拓展包有三个，分别是："><a href="#注明备忘：这里使用的编辑器是vscode，下载的拓展包有三个，分别是：" class="headerlink" title="注明备忘：这里使用的编辑器是vscode，下载的拓展包有三个，分别是："></a>注明备忘：这里使用的编辑器是vscode，下载的拓展包有三个，分别是：</h3><ol><li>markdown all in one</li><li>markdown preview Enhanced</li><li>pasted Image    &#x2F;&#x2F;这个跟别的博主学的，用于方便copy网页图片。个人来说如果单纯本地预览确实超级方便，但是对于我来说有点鸡肋，然后放在本地并不是很好管理。</li></ol><p><strong>学到了新的我也会持续更新加在后面</strong></p><hr><h1 id="一：标题："><a href="#一：标题：" class="headerlink" title="一：标题："></a>一：标题：</h1><p><strong>markdown部分：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 这篇文章用来学习markdown语法，这是一级标题。#H1</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 这篇文章用来学习markdown语法，这是二级标题。#H2</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 这篇文章用来学习markdown语法，这是三级标题。#H3</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 其实切换起来多加几个#号就可以了，这里是四级标题。#H4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>渲染效果：</strong></p><h1 id="这篇文章用来学习markdown语法，这是一级标题。-H1"><a href="#这篇文章用来学习markdown语法，这是一级标题。-H1" class="headerlink" title="这篇文章用来学习markdown语法，这是一级标题。#H1"></a>这篇文章用来学习markdown语法，这是一级标题。#H1</h1><h2 id="这篇文章用来学习markdown语法，这是二级标题。-H2"><a href="#这篇文章用来学习markdown语法，这是二级标题。-H2" class="headerlink" title="这篇文章用来学习markdown语法，这是二级标题。#H2"></a>这篇文章用来学习markdown语法，这是二级标题。#H2</h2><h3 id="这篇文章用来学习markdown语法，这是三级标题。-H3"><a href="#这篇文章用来学习markdown语法，这是三级标题。-H3" class="headerlink" title="这篇文章用来学习markdown语法，这是三级标题。#H3"></a>这篇文章用来学习markdown语法，这是三级标题。#H3</h3><h4 id="其实切换起来多加几个-号就可以了，这里是四级标题。-H4"><a href="#其实切换起来多加几个-号就可以了，这里是四级标题。-H4" class="headerlink" title="其实切换起来多加几个#号就可以了，这里是四级标题。#H4"></a>其实切换起来多加几个#号就可以了，这里是四级标题。#H4</h4><hr><h1 id="二：正文："><a href="#二：正文：" class="headerlink" title="二：正文："></a>二：正文：</h1><p>这样直接写就是正文。<br>末尾添加多余两个空格再回车，实现创建换行</p><p>换了一行<br>又换了一行   </p><p>空一行，换了一段。（换行换段我这里自动识别了）</p><hr><h1 id="三：加粗，斜体，斜体加粗，删除线："><a href="#三：加粗，斜体，斜体加粗，删除线：" class="headerlink" title="三：加粗，斜体，斜体加粗，删除线："></a>三：加粗，斜体，斜体加粗，删除线：</h1><p><strong>tips：（ctl+shift+home是选中当前行鼠标前内容，end当前行末，home当前行首）</strong></p><h3 id="加粗："><a href="#加粗：" class="headerlink" title="加粗："></a>加粗：</h3><p>加粗前后各（** ）包住</p><p><strong>markdown部分：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**我现在变粗体了**</span></span><br><span class="line"><span class="strong">**也可也ctl+b加粗**</span></span><br></pre></td></tr></table></figure><p><strong>渲染效果：</strong><br><strong>我现在变粗体了</strong><br><strong>也可也ctl+b加粗</strong></p><hr><h3 id="斜体，斜体加粗："><a href="#斜体，斜体加粗：" class="headerlink" title="斜体，斜体加粗："></a>斜体，斜体加粗：</h3><p>斜体前后各（* )包住<br>斜体并加粗就是前后各(*** )包住</p><p><strong>markdown部分：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*我现在歪了*</span>   //斜体</span><br><span class="line"><span class="strong">**<span class="emphasis">*也可也ctl+i选中变成斜体，然后再ctl+b加粗*</span>**</span> //<span class="strong">**<span class="emphasis">*这样三个是斜体加粗</span></span></span><br></pre></td></tr></table></figure><p><strong>渲染效果：</strong><br><em>我现在歪了</em><br><em><strong>也可也ctl+i选中变成斜体</strong></em></p><hr><h3 id="删除线："><a href="#删除线：" class="headerlink" title="删除线："></a>删除线：</h3><p>要加删除线的文字左右分别用两个~~号包起来</p><p><strong>markdown部分：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~我被杠掉了~~</span><br></pre></td></tr></table></figure><p><strong>渲染效果：</strong><br><del>我被杠掉了</del></p><hr><h1 id="四：引用，分割线："><a href="#四：引用，分割线：" class="headerlink" title="四：引用，分割线："></a>四：引用，分割线：</h1><p>引用：在引用的文字前加&gt;就行。引用也可以嵌套，只要不断&gt;&gt;&gt;&gt;&gt;&gt;就行。<br>分割线：分割线就是三个或以上的-或者*</p><p><strong>markdown部分：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br><span class="line"><span class="section">---                          //分割线</span></span><br><span class="line"><span class="section">----</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*                          //分割线</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span>**</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><p><strong>渲染效果：</strong></p><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p><blockquote><blockquote><blockquote><p>这是引用的内容</p></blockquote></blockquote></blockquote></blockquote></blockquote><hr><hr><hr><hr><hr><h1 id="五：序号，段落小圆点："><a href="#五：序号，段落小圆点：" class="headerlink" title="五：序号，段落小圆点："></a>五：序号，段落小圆点：</h1><p><strong>markdown部分：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">   1.</span> 这样是有序，（1.+空格），换行会自动添加第二个序号</span><br><span class="line"><span class="bullet">   2.</span> 这样就有第二个序号</span><br><span class="line"><span class="bullet">   3.</span> - 第三行打个这样形式的</span><br><span class="line"><span class="bullet">      1.</span> tab，二级序号</span><br><span class="line"><span class="bullet">      2.</span> 二级序号第二个</span><br><span class="line"><span class="bullet">      3.</span> 二级序号第三个</span><br><span class="line"><span class="bullet">      4.</span> 第四</span><br><span class="line"><span class="code">          如果直接换一行，换行是这样的。</span></span><br><span class="line"><span class="code">如果这样加一些文字，即使没有缩进，渲染出来也还会是在二级序号的段落内</span></span><br><span class="line"><span class="code">         1. 三级序号</span></span><br><span class="line"><span class="code">         66. 如果乱打序号，渲染出来的序号其实还会是正确的。比如这一行打的66，渲染还会是2号</span></span><br><span class="line"><span class="code">         - 这样打是个小圆点点（-加一个空格）</span></span><br><span class="line"><span class="code">         - 换行会自动给你补全这个小圆点</span></span><br><span class="line"><span class="code">         </span></span><br></pre></td></tr></table></figure><p><strong>渲染效果：</strong></p><ol><li>这样是有序，（1.+空格），换行会自动添加第二个序号</li><li>这样就有第二个序号</li><li><ul><li>第三行打个这样形式的</li></ul><ol><li>tab，二级序号</li><li>二级序号第二个</li><li>二级序号第三个</li><li>第四<br> 如果直接换一行，换行是这样的。<br>如果这样加一些文字，即使没有缩进，渲染出来也还会是在二级序号的段落内<ol><li>三级序号</li><li>如果乱打序号，渲染出来的序号其实还会是正确的。比如这一行打的66，渲染还会是2号</li></ol><ul><li>这样打是个小圆点点（-加一个空格）</li><li>换行会自动给你补全这个小圆点</li></ul></li></ol></li></ol><hr><h1 id="六：添加图片："><a href="#六：添加图片：" class="headerlink" title="六：添加图片："></a>六：添加图片：</h1><p><strong>网络图片链接：</strong><br>ctl+alt+v，粘贴从在线网页上复制的内容，使用了拓展包，所以默认会加载到正在编辑的markdown的文件夹下<br>网络图片可以直接使用它的链接（不过网络图片连接很可能不知道啥时候就挂了，我自己用的图床是阿里云OSS，先测试几个月看看效果）</p><p><strong>markdown源码（此图片来自网络，如侵权，可联系删除）：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">beishangwa</span>](<span class="link">https://img.zcool.cn/community/0121c859e056fea80121ae0c405fd6.jpg@1280w_1l_2o_100sh.jpg</span>)</span><br></pre></td></tr></table></figure><p>下面的图就是网页上copy下来的悲伤蛙渲染效果。使用 ![]() 来链接图片。</p><p><img src="https://img.zcool.cn/community/0121c859e056fea80121ae0c405fd6.jpg@1280w_1l_2o_100sh.jpg" alt="beishangwa"></p><p><strong>本地图片链接方式：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](<span class="link">./beishangwa.png</span>)</span><br></pre></td></tr></table></figure><p>如果这样的话就可以使用本地的悲伤蛙（找不到路径需要.&#x2F;一下，vs可以识别路径里的图，这里估计会挂，我本地应该不在这个路径，建议放在相应的md文件夹内方便定义路径）</p><hr><h1 id="七：转义字符："><a href="#七：转义字符：" class="headerlink" title="七：转义字符："></a>七：转义字符：</h1><p><strong>markdown部分：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">| character | name     |</span><br><span class="line">| --------- | -------- |</span><br><span class="line">| \\        | 反斜杠   |</span><br><span class="line">| \`        | 反引号   |</span><br><span class="line">| \<span class="emphasis">*        | 星号     |</span></span><br><span class="line"><span class="emphasis">| \_        | 下划线   |</span></span><br><span class="line"><span class="emphasis">| \&#123;\&#125;      | 大括号   |</span></span><br><span class="line"><span class="emphasis">| \[\]      | 中括号   |</span></span><br><span class="line"><span class="emphasis">| \(\)      | 小括号   |</span></span><br><span class="line"><span class="emphasis">| \#        | 井号     |</span></span><br><span class="line"><span class="emphasis">| \+        | 加号     |</span></span><br><span class="line"><span class="emphasis">| \-        | 减号     |</span></span><br><span class="line"><span class="emphasis">| \.        | 英文句号 |</span></span><br><span class="line"><span class="emphasis">| \!        | 感叹号   |</span></span><br></pre></td></tr></table></figure><p><strong>渲染效果：</strong></p><table><thead><tr><th>character</th><th>name</th></tr></thead><tbody><tr><td>\</td><td>反斜杠</td></tr><tr><td>`</td><td>反引号</td></tr><tr><td>*</td><td>星号</td></tr><tr><td>_</td><td>下划线</td></tr><tr><td>{}</td><td>大括号</td></tr><tr><td>[]</td><td>中括号</td></tr><tr><td>()</td><td>小括号</td></tr><tr><td>#</td><td>井号</td></tr><tr><td>+</td><td>加号</td></tr><tr><td>-</td><td>减号</td></tr><tr><td>.</td><td>英文句号</td></tr><tr><td>!</td><td>感叹号</td></tr></tbody></table><hr><h1 id="八：表格"><a href="#八：表格" class="headerlink" title="八：表格"></a>八：表格</h1><p>(源码在vs显示的格式化修改：alt+shift+f)<br>表格中均默认左对齐，右对齐使用—后加：，或者居中对齐使用—前后各：：</p><p><strong>markdown部分：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">##### 左对齐：</span></span><br><span class="line">| 姓名   | 颜色 | 种族类型 |</span><br><span class="line">| ------ | ---- | -------- |</span><br><span class="line">| 悲伤蛙 | 绿   | 蛙子     |</span><br><span class="line">| 哈士奇 | 黑白 | 狗子     |</span><br><span class="line"></span><br><span class="line"><span class="section">##### 右对齐：</span></span><br><span class="line">| 姓名   | 颜色 | 种族类型 |</span><br><span class="line">| ------ | ---: | -------: |</span><br><span class="line">| 悲伤蛙 |   绿 |     蛙子 |</span><br><span class="line">| 哈士奇 |   黑 |     狗子 |</span><br><span class="line"></span><br><span class="line"><span class="section">##### 居中对齐：</span></span><br><span class="line">| 姓名   | 颜色  | 种族类型 |</span><br><span class="line">| ------ | :---: | :------: |</span><br><span class="line">| 悲伤蛙 |  绿   |   蛙子   |</span><br><span class="line">| 哈士奇 |  黑   |   狗子   |</span><br></pre></td></tr></table></figure><p><strong>渲染效果：</strong></p><h5 id="左对齐："><a href="#左对齐：" class="headerlink" title="左对齐："></a>左对齐：</h5><table><thead><tr><th>姓名</th><th>颜色</th><th>种族类型</th></tr></thead><tbody><tr><td>悲伤蛙</td><td>绿</td><td>蛙子</td></tr><tr><td>哈士奇</td><td>黑白</td><td>狗子</td></tr></tbody></table><h5 id="右对齐："><a href="#右对齐：" class="headerlink" title="右对齐："></a>右对齐：</h5><table><thead><tr><th>姓名</th><th align="right">颜色</th><th align="right">种族类型</th></tr></thead><tbody><tr><td>悲伤蛙</td><td align="right">绿</td><td align="right">蛙子</td></tr><tr><td>哈士奇</td><td align="right">黑</td><td align="right">狗子</td></tr></tbody></table><h5 id="居中对齐："><a href="#居中对齐：" class="headerlink" title="居中对齐："></a>居中对齐：</h5><table><thead><tr><th>姓名</th><th align="center">颜色</th><th align="center">种族类型</th></tr></thead><tbody><tr><td>悲伤蛙</td><td align="center">绿</td><td align="center">蛙子</td></tr><tr><td>哈士奇</td><td align="center">黑</td><td align="center">狗子</td></tr></tbody></table><hr><h1 id="九：正文对齐方式："><a href="#九：正文对齐方式：" class="headerlink" title="九：正文对齐方式："></a>九：正文对齐方式：</h1><p>markdown我查了一下好像是没有对齐的，但是它基本支持html的语法，所以我们可以写成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">**居中对齐：**</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span>帅哥美女一键三连<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"></span><br><span class="line">**左对齐：**</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">&quot;left&quot;</span>&gt;</span>帅哥美女一键三连<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">**右对齐：**</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">&quot;right&quot;</span>&gt;</span>帅哥美女一键三连<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>渲染效果：</strong></p><p><strong>居中对齐：</strong></p><center>帅哥美女一键三连</center><p><strong>左对齐：</strong></p><p align="left">帅哥美女一键三连</p><p><strong>右对齐：</strong></p><p align="right">帅哥美女一键三连</p><hr><h1 id="十：插入链接"><a href="#十：插入链接" class="headerlink" title="十：插入链接"></a>十：插入链接</h1><p>还是ctl + C 然后选中需要添加链接的文字ctl + V<br>这是一个<a href="https://markdown.com.cn/basic-syntax/">markdown语法</a>链接</p><hr><h1 id="十一：代码框"><a href="#十一：代码框" class="headerlink" title="十一：代码框"></a>十一：代码框</h1><p>代码前后使用&#96;&#96;&#96;包裹,并指定一种语言</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\  <span class="code">```markdown</span></span><br><span class="line"><span class="code">      中间是内容</span></span><br><span class="line"><span class="code">\  ```</span></span><br></pre></td></tr></table></figure><p><strong>渲染效果：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">中间是内容</span><br></pre></td></tr></table></figure><hr><h1 id="十二-hexo内插入网页视频"><a href="#十二-hexo内插入网页视频" class="headerlink" title="十二: hexo内插入网页视频"></a>十二: hexo内插入网页视频</h1><h5 id="目前是使用raw的方式：（markdown应该不可以直接渲染预览，但是hexo是支持的，自适应方面还阔以）"><a href="#目前是使用raw的方式：（markdown应该不可以直接渲染预览，但是hexo是支持的，自适应方面还阔以）" class="headerlink" title="目前是使用raw的方式：（markdown应该不可以直接渲染预览，但是hexo是支持的，自适应方面还阔以）"></a>目前是使用raw的方式：（markdown应该不可以直接渲染预览，但是hexo是支持的，自适应方面还阔以）</h5><p><strong>markdown部分：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">iframe</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=939470868&amp;bvid=BV1VT4y1B7QL&amp;cid=731375438&amp;page=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: absolute; width: 100%; </span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">height: 100%; left: 0; top: 0;&quot;</span>&gt;</span></span> <span class="language-xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>渲染效果：</strong></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=939470868&bvid=BV1VT4y1B7QL&cid=731375438&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><hr><h1 id="十三-emoji"><a href="#十三-emoji" class="headerlink" title="十三: emoji"></a>十三: emoji</h1><p>推荐网站<a href="https://emojipedia.org/">emojipedia</a><br>直接复制粘贴就好，可以正确渲染<br>示例：<br>🍇<br>🐗<br>🙃<br>🗻</p><hr><p>当然，也可以使用 <a href="https://unicode.org/emoji/charts/full-emoji-list.html">full emoji list</a><br>格式：<code>&amp;#x  +unicode + ;</code></p><p>范例：<br><code>&amp;#x1F601;</code><br><code>&amp;#x1F602;</code></p><p>渲染效果：<br>&amp;#x1F601;<br>&amp;#x1F602;</p><hr><h1 id="十四-图床"><a href="#十四-图床" class="headerlink" title="十四: 图床"></a>十四: 图床</h1><p>我配置的是阿里云OSS + PicGo + vscode的方案<br>由于我的编辑器是vscode，所以在vscode上传图片的快捷键如下：</p><p>上传截图：ctl+alt+u</p><hr><p><strong><center>待续，学到后再加</center></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;注明备忘：这里使用的编辑器是vscode，下载的拓展包有三个，分别是：&quot;&gt;&lt;a href=&quot;#注明备忘：这里使用的编辑器是vscode，下载的拓展包有三个，分别是：&quot; class=&quot;headerlink&quot; title=&quot;注明备忘：这里使用的编辑器是vscode，下</summary>
      
    
    
    
    <category term="-Markdown" scheme="http://example.com/categories/Markdown/"/>
    
    
    <category term="-学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>UE4以及相关工具学习列表合辑</title>
    <link href="http://example.com/2022/09/09/unreal/"/>
    <id>http://example.com/2022/09/09/unreal/</id>
    <published>2022-09-09T10:32:14.000Z</published>
    <updated>2022-09-23T08:42:45.258Z</updated>
    
    <content type="html"><![CDATA[<p>这篇是我的UE学习记录了，也算是我的UE学习置顶占位。2022是我学习UE的第一年，来记录一下<br>然后写的不一定是教程笔记哈，有些别的好的我也会随意写写放上来。<br>详细如下，都有各个的部分的站内链接<br>每篇写好了就会更新！<br>博客是新开的，整理上来需要时间，如果有兴趣讨论的朋友也可通过我主页的联系方式找我哈！</p><hr><h1 id="🚩UE材质基础"><a href="#🚩UE材质基础" class="headerlink" title="🚩UE材质基础"></a>🚩UE材质基础</h1><h2 id="一：UE4官方材质课-基础篇"><a href="#一：UE4官方材质课-基础篇" class="headerlink" title="一：UE4官方材质课_基础篇"></a>一：UE4官方材质课_基础篇</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/uefoundation_cover.png" alt="uefoundation_cover"><br><strong>站内link：</strong></p><a href="/2022/09/13/ue_MatClass_foundation/" title="UE4官方材质课_基础篇">UE4官方材质课_基础篇</a><hr><h1 id="🚩UE灯光技巧："><a href="#🚩UE灯光技巧：" class="headerlink" title="🚩UE灯光技巧："></a>🚩UE灯光技巧：</h1><h2 id="一：UE灯光流程以及方案（Light-a-project-in-UE）"><a href="#一：UE灯光流程以及方案（Light-a-project-in-UE）" class="headerlink" title="一：UE灯光流程以及方案（Light a project in UE）"></a>一：UE灯光流程以及方案（Light a project in UE）</h2><p><strong>站内link：</strong></p><a href="/2022/09/18/ue_Light_a_Project_in_UE/" title="Light_a_Project_in_UE">Light_a_Project_in_UE</a>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇是我的UE学习记录了，也算是我的UE学习置顶占位。2022是我学习UE的第一年，来记录一下&lt;br&gt;然后写的不一定是教程笔记哈，有些别的好的我也会随意写写放上来。&lt;br&gt;详细如下，都有各个的部分的站内链接&lt;br&gt;每篇写好了就会更新！&lt;br&gt;博客是新开的，整理上来需要时间，</summary>
      
    
    
    
    <category term="-UE4" scheme="http://example.com/categories/UE4/"/>
    
    
    <category term="-学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>houdini以及3D数学学习列表合辑</title>
    <link href="http://example.com/2022/09/09/houdini/"/>
    <id>http://example.com/2022/09/09/houdini/</id>
    <published>2022-09-09T10:09:03.000Z</published>
    <updated>2022-10-04T10:17:41.684Z</updated>
    
    <content type="html"><![CDATA[<ul><li>这篇是我的Houdini学习记录了，也算是我的Houdini学习置顶占位。</li><li>同时为了补足我3D的知识，也在学习3D相关的数学（都是比较基础的部分）。</li><li>然后写的不一定是教程笔记哈，有些别的好的素材以及我也会随意写写放上来！</li><li>详细如下，都有各个的部分的站内链接，每篇写好了就会更新！</li><li>博客是新开的，整理上来需要时间，如果有兴趣讨论的朋友也可通过我主页的联系方式找我哈！</li></ul><hr><h1 id="🚩PCG部分"><a href="#🚩PCG部分" class="headerlink" title="🚩PCG部分"></a>🚩PCG部分</h1><h2 id="一：🏘️湖边小屋学习记录🏘️"><a href="#一：🏘️湖边小屋学习记录🏘️" class="headerlink" title="一：🏘️湖边小屋学习记录🏘️"></a>一：🏘️湖边小屋学习记录🏘️</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lakeHouse_top.png" alt="lakeHouse_top"><br>老经典了，还没看过兄弟姐妹的我不允许你还没看过！这是<a href="https://www.bilibili.com/video/BV1rW411j7fo?spm_id_from=333.337.search-card.all.click&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接</a></p><blockquote><p>（目前小屋笔记还在整理中，link内没东西。）</p></blockquote><p><strong>湖边小屋第一篇站内link：</strong></p><a href="/2022/09/13/houdini_lakeHouse_p1/" title="Houdini湖边小屋学习（一）">Houdini湖边小屋学习（一）</a><p><strong>湖边小屋第二篇站内link：</strong><br><strong>湖边小屋第三篇站内link：</strong></p><hr><h1 id="🚩Houdini节点知识学习以及补充部分"><a href="#🚩Houdini节点知识学习以及补充部分" class="headerlink" title="🚩Houdini节点知识学习以及补充部分"></a>🚩Houdini节点知识学习以及补充部分</h1><h2 id="一：➰关于forEach和forLoop在Houdini中的用法➰"><a href="#一：➰关于forEach和forLoop在Houdini中的用法➰" class="headerlink" title="一：➰关于forEach和forLoop在Houdini中的用法➰"></a>一：➰关于forEach和forLoop在Houdini中的用法➰</h2><p><strong>站内link：</strong></p><a href="/2022/09/13/houdini_foreach/" title="Houdini 中for-each 和for-loop 节点">Houdini 中for-each 和for-loop 节点</a><h2 id="二："><a href="#二：" class="headerlink" title="二："></a>二：</h2><hr><h1 id="🚩3D数学部分"><a href="#🚩3D数学部分" class="headerlink" title="🚩3D数学部分"></a>🚩3D数学部分</h1><h2 id="一：🧮3Blue1Brown线性代数的本质🧮"><a href="#一：🧮3Blue1Brown线性代数的本质🧮" class="headerlink" title="一：🧮3Blue1Brown线性代数的本质🧮"></a>一：🧮3Blue1Brown线性代数的本质🧮</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/a3Blue1Brown.png" alt="a3Blue1Brown"><br><strong>第一节站内Link：</strong></p><a href="/2022/09/22/math_Essense_of_Linear_Algebra_P01/" title="3Blue1Brown_线代本质第一章：向量究竟是什么">3Blue1Brown_线代本质第一章：向量究竟是什么</a><p><strong>第二节站内Link：</strong></p><a href="/2022/09/22/math_Essense_of_Linear_Algebra_P02/" title="3Blue1Brown_线代本质第二章：线性组合，张成的空间与基">3Blue1Brown_线代本质第二章：线性组合，张成的空间与基</a><p><strong>第三节站内Link：</strong></p><a href="/2022/09/24/math_Essense_of_Linear_Algebra_P03/" title="3Blue1Brown_线代本质第三章：矩阵与线性变换">3Blue1Brown_线代本质第三章：矩阵与线性变换</a><p><strong>第四节站内Link：</strong></p><a href="/2022/09/25/math_Essense_of_Linear_Algebra_P04/" title="3Blue1Brown_线代本质第四章：矩阵乘法与线性变换复合；三维空间中的线性变换">3Blue1Brown_线代本质第四章：矩阵乘法与线性变换复合；三维空间中的线性变换</a><p><strong>第五节站内Link：</strong></p><a href="/2022/09/26/math_Essense_of_Linear_Algebra_P05/" title="3Blue1Brown_线代本质第五章：行列式">3Blue1Brown_线代本质第五章：行列式</a><p><strong>第六节站内Link：</strong></p><a href="/2022/09/27/math_Essense_of_Linear_Algebra_P06/" title="3Blue1Brown_线代本质第六章：逆矩阵，列空间与零空间">3Blue1Brown_线代本质第六章：逆矩阵，列空间与零空间</a><p><strong>第七节站内Link：</strong></p><a href="/2022/09/29/math_Essense_of_Linear_Algebra_P07/" title="3Blue1Brown_线代本质第七章：点积与对偶性">3Blue1Brown_线代本质第七章：点积与对偶性</a><p><strong>第八节站内Link：</strong></p><a href="/2022/10/03/math_Essense_of_Linear_Algebra_P08/" title="3Blue1Brown_线代本质第八章：叉积的标准介绍">3Blue1Brown_线代本质第八章：叉积的标准介绍</a>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;这篇是我的Houdini学习记录了，也算是我的Houdini学习置顶占位。&lt;/li&gt;
&lt;li&gt;同时为了补足我3D的知识，也在学习3D相关的数学（都是比较基础的部分）。&lt;/li&gt;
&lt;li&gt;然后写的不一定是教程笔记哈，有些别的好的素材以及我也会随意写写放上来！&lt;/l</summary>
      
    
    
    
    <category term="-Houdini" scheme="http://example.com/categories/Houdini/"/>
    
    
    <category term="-学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>这是一篇测试</title>
    <link href="http://example.com/2022/09/07/%E6%B5%8B%E8%AF%95%E4%B8%80/"/>
    <id>http://example.com/2022/09/07/%E6%B5%8B%E8%AF%95%E4%B8%80/</id>
    <published>2022-09-07T07:35:04.000Z</published>
    <updated>2022-09-08T12:44:50.006Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个测试，看看第一篇是否顺利保存并打开！<br>这里只是一个简陋的文本所以跳过就行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是一个测试，看看第一篇是否顺利保存并打开！&lt;br&gt;这里只是一个简陋的文本所以跳过就行&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
