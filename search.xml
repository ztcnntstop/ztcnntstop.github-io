<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>houdini以及3D数学学习列表合辑</title>
    <url>/2022/09/09/houdini/</url>
    <content><![CDATA[<ul>
<li>这篇是我的Houdini学习记录了，也算是我的Houdini学习置顶占位。</li>
<li>同时为了补足我3D的知识，也在学习3D相关的数学（都是比较基础的部分）。</li>
<li>然后写的不一定是教程笔记哈，有些别的好的素材以及我也会随意写写放上来！</li>
<li>详细如下，都有各个的部分的站内链接，每篇写好了就会更新！</li>
<li>博客是新开的，整理上来需要时间，如果有兴趣讨论的朋友也可通过我主页的联系方式找我哈！</li>
</ul>
<hr>
<h1 id="🚩PCG部分"><a href="#🚩PCG部分" class="headerlink" title="🚩PCG部分"></a>🚩PCG部分</h1><h2 id="一：🏘️湖边小屋学习记录🏘️"><a href="#一：🏘️湖边小屋学习记录🏘️" class="headerlink" title="一：🏘️湖边小屋学习记录🏘️"></a>一：🏘️湖边小屋学习记录🏘️</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lakeHouse_top.png" alt="lakeHouse_top"><br>老经典了，还没看过兄弟姐妹的我不允许你还没看过！这是<a href="https://www.bilibili.com/video/BV1rW411j7fo?spm_id_from=333.337.search-card.all.click&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接</a></p>
<blockquote>
<p>（目前小屋笔记还在整理中，link内没东西。）</p>
</blockquote>
<p><strong>湖边小屋第一篇站内link：</strong></p>
<a href="/2022/09/13/houdini_lakeHouse_p1/" title="Houdini湖边小屋学习（一）">Houdini湖边小屋学习（一）</a>

<p><strong>湖边小屋第二篇站内link：</strong><br><strong>湖边小屋第三篇站内link：</strong></p>
<hr>
<h1 id="🚩Houdini节点知识学习以及补充部分"><a href="#🚩Houdini节点知识学习以及补充部分" class="headerlink" title="🚩Houdini节点知识学习以及补充部分"></a>🚩Houdini节点知识学习以及补充部分</h1><h2 id="一：➰关于forEach和forLoop在Houdini中的用法➰"><a href="#一：➰关于forEach和forLoop在Houdini中的用法➰" class="headerlink" title="一：➰关于forEach和forLoop在Houdini中的用法➰"></a>一：➰关于forEach和forLoop在Houdini中的用法➰</h2><p><strong>站内link：</strong></p>
<a href="/2022/09/13/houdini_foreach/" title="Houdini 中for-each 和for-loop 节点">Houdini 中for-each 和for-loop 节点</a>

<h2 id="二："><a href="#二：" class="headerlink" title="二："></a>二：</h2><hr>
<h1 id="🚩3D数学部分"><a href="#🚩3D数学部分" class="headerlink" title="🚩3D数学部分"></a>🚩3D数学部分</h1><h2 id="一：🧮3Blue1Brown线性代数的本质🧮"><a href="#一：🧮3Blue1Brown线性代数的本质🧮" class="headerlink" title="一：🧮3Blue1Brown线性代数的本质🧮"></a>一：🧮3Blue1Brown线性代数的本质🧮</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/a3Blue1Brown.png" alt="a3Blue1Brown"><br><strong>第一节站内Link：</strong></p>
<a href="/2022/09/22/math_Essense_of_Linear_Algebra_P01/" title="3Blue1Brown_线代本质第一章：向量究竟是什么">3Blue1Brown_线代本质第一章：向量究竟是什么</a>

<p><strong>第二节站内Link：</strong></p>
<a href="/2022/09/22/math_Essense_of_Linear_Algebra_P02/" title="3Blue1Brown_线代本质第二章：线性组合，张成的空间与基">3Blue1Brown_线代本质第二章：线性组合，张成的空间与基</a>

<p><strong>第三节站内Link：</strong></p>
<a href="/2022/09/24/math_Essense_of_Linear_Algebra_P03/" title="3Blue1Brown_线代本质第三章：矩阵与线性变换">3Blue1Brown_线代本质第三章：矩阵与线性变换</a>
]]></content>
      <categories>
        <category>-Houdini</category>
      </categories>
      <tags>
        <tag>-学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Houdini 中for-each 和for-loop 节点</title>
    <url>/2022/09/13/houdini_foreach/</url>
    <content><![CDATA[<h1 id="Houdini-中for-each-和for-loop-节点"><a href="#Houdini-中for-each-和for-loop-节点" class="headerlink" title="Houdini 中for-each 和for-loop 节点"></a>Houdini 中for-each 和for-loop 节点</h1><p>学习houdini时间不长，刚入门的时候就一直对foreach的使用比较迷糊，在这里写一篇学习笔记来认识一下这个使用方式，比较基础 。如果有问题，请各位大佬及时补充和指正！</p>
<hr>
<h2 id="Houdini中关于循环的节点简介："><a href="#Houdini中关于循环的节点简介：" class="headerlink" title="Houdini中关于循环的节点简介："></a>Houdini中关于循环的节点简介：</h2><p>houdini中一共给了这6个框架：<br><strong>1. for-each Number<br>2. for-each point<br>3. for-each primitive<br>4. for-each connected Piece<br>5. for-each Named Primitive<br>6. for-loop with Feedback</strong></p>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/foreach2.png" alt="foreach2"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/foreach1.png" alt="foreach1"><br>（在这里说明我用的是houdini 18之后的版本，如果版本太靠前应该foreach节点跟这个有所出入）</p>
<ul>
<li>这个框架它本身的作用就是实现for循环，如果不想用它的框架，也可以自己创建Block begin和Block end来搭建for循环。</li>
<li>其中，<strong>for-each point，for-each primitive，for-each connected Piece和for-each Named Primitive</strong>的构造是相似的，使用的方法也是一样的，只是针对的元素不同（点，面，name属性）</li>
<li><strong>connectivity</strong>是创造了一个class属性，根据class属性处理导入这个元素。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20220921233222.png" alt="foreach2"></li>
<li>数据都是从Block Begin传入，我们中间可以任意添加节点来完成我们想要针对这个元素处理的操作，这个数据给每个元素循环处理后，最终由block end输出。end中可以选择Feedback Each Iteration来显示每一次结果，或者Merge Each Iteration来显示所有结果。</li>
</ul>
<h2 id="例子一：随机颜色："><a href="#例子一：随机颜色：" class="headerlink" title="例子一：随机颜色："></a>例子一：随机颜色：</h2><ul>
<li>针对<strong>for-each point，for-each primitive，for-each connected Piece和for-each Named Primitive</strong>这四个框架可以做出此示例。</li>
<li>循环迭代次数不是自动给出的，需要通过Block Begin中的“Create meta import Node来创建；它的detail上会有iteration的参数。若我们希望使用foreach，来达到进入循环的元素被进行的处理或者操作有所变化，那么我们也是通过iteration来实现的。</li>
</ul>
<h3 id="for-each-point："><a href="#for-each-point：" class="headerlink" title="for-each point："></a>for-each point：</h3><ul>
<li>使用vex做一个简单的颜色随机，注意iteration不要写错<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/foreach_randCol_pt.png" alt="foreach_randCol_pt"></li>
</ul>
<h3 id="for-each-primitive："><a href="#for-each-primitive：" class="headerlink" title="for-each primitive："></a>for-each primitive：</h3><ul>
<li>对于primitive也是完全一样的<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/foreach_randCol_prim.png" alt="foreach_randCol_prim"></li>
</ul>
<h3 id="for-each-connected-Piece："><a href="#for-each-connected-Piece：" class="headerlink" title="for-each connected Piece："></a>for-each connected Piece：</h3><ul>
<li>对于for-each connected Piece，则是根据它的class属性，处理它连续的元素。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/foreach_randCol_connPiec.png" alt="foreach_randCol_class"></li>
</ul>
<h3 id="for-each-Named-Primitive："><a href="#for-each-Named-Primitive：" class="headerlink" title="for-each Named Primitive："></a>for-each Named Primitive：</h3><ul>
<li>for-each Named Primitive也是根据name属性来处理元素（属性是在piece attribute上的，可以更改，但必须保持输入输出的是一致的，否则不能匹配）</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/foreach_randCol_name.png" alt="foreach_randCol_name"></li>
</ul>
<h2 id="for-each-Number的用法："><a href="#for-each-Number的用法：" class="headerlink" title="for-each Number的用法："></a>for-each Number的用法：</h2><ul>
<li>可以看出，它的Block Beginn中的method变成了“Fetch Input”，它的Block end中 Iteration Method变为了“By Count”。 他并不是对每个元素进行处理，而是对他本身进行拷贝，进入循环，它的迭代次数就是它的拷贝次数。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/foreach_number.png" alt="foreach_number"></li>
<li>由上示例，它每次的循环均为它的input，根据iteration的次数来做重复。</li>
</ul>
<h2 id="for-Loop的用法："><a href="#for-Loop的用法：" class="headerlink" title="for-Loop的用法："></a>for-Loop的用法：</h2><ul>
<li>for-loop with Feedback中，它的默认Block Beginn中的method是“Fetch FeedBack”，它的Block end中 Iteration Method是“By Count”；它的Gather Method则默认是Feedback Each Iteration。如果for-each Number是指对本身的元素进行处理，那么for-loop with Feedback就是对循环整体进行处理。</li>
<li>它是以上一个循环的end的结果作为下一次循环的起点，进行再次循环，一直循环操作我们在循环内设置的指令，直到迭代次数结束。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/forLoop.png" alt="forLoop"></li>
<li>由上图示例，这个rubbertoy朝着x轴正向移动，每次移动单位为1米，循环了五次，移动到现在5米的位置。</li>
<li>下图是merge each iteration，显示每次循环结果，可以更清晰看出。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/forLoop_MergeEachIteration.png" alt="forLoop_MergeEachIteration"></li>
</ul>
]]></content>
      <categories>
        <category>-Houdini</category>
      </categories>
      <tags>
        <tag>-Houdini节点</tag>
      </tags>
  </entry>
  <entry>
    <title>Houdini湖边小屋学习（一）</title>
    <url>/2022/09/13/houdini_lakeHouse_p1/</url>
    <content><![CDATA[<p>🐸本文为我的houdini湖边小屋笔记第一篇内容，作为我PCG的进阶学习部分来记录一下~~~<br>🐸目前是<strong>第一篇</strong><br>🐸加油加油！</p>
<hr>
<h1 id="湖边小屋第一篇"><a href="#湖边小屋第一篇" class="headerlink" title="湖边小屋第一篇"></a>湖边小屋第一篇</h1><h2 id="第一部分-Base-shape："><a href="#第一部分-Base-shape：" class="headerlink" title="第一部分 Base shape："></a>第一部分 Base shape：</h2>]]></content>
      <categories>
        <category>-Houdini</category>
      </categories>
      <tags>
        <tag>-PCG</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基本语法</title>
    <url>/2022/09/13/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h3 id="注明备忘：这里使用的编辑器是vscode，下载的拓展包有三个，分别是："><a href="#注明备忘：这里使用的编辑器是vscode，下载的拓展包有三个，分别是：" class="headerlink" title="注明备忘：这里使用的编辑器是vscode，下载的拓展包有三个，分别是："></a>注明备忘：这里使用的编辑器是vscode，下载的拓展包有三个，分别是：</h3><ol>
<li>markdown all in one</li>
<li>markdown preview Enhanced</li>
<li>pasted Image    &#x2F;&#x2F;这个跟别的博主学的，用于方便copy网页图片。个人来说如果单纯本地预览确实超级方便，但是对于我来说有点鸡肋，然后放在本地并不是很好管理。</li>
</ol>
<p><strong>学到了新的我也会持续更新加在后面</strong></p>
<hr>
<h1 id="一：标题："><a href="#一：标题：" class="headerlink" title="一：标题："></a>一：标题：</h1><p><strong>markdown部分：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 这篇文章用来学习markdown语法，这是一级标题。#H1</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 这篇文章用来学习markdown语法，这是二级标题。#H2</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 这篇文章用来学习markdown语法，这是三级标题。#H3</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 其实切换起来多加几个#号就可以了，这里是四级标题。#H4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>渲染效果：</strong></p>
<h1 id="这篇文章用来学习markdown语法，这是一级标题。-H1"><a href="#这篇文章用来学习markdown语法，这是一级标题。-H1" class="headerlink" title="这篇文章用来学习markdown语法，这是一级标题。#H1"></a>这篇文章用来学习markdown语法，这是一级标题。#H1</h1><h2 id="这篇文章用来学习markdown语法，这是二级标题。-H2"><a href="#这篇文章用来学习markdown语法，这是二级标题。-H2" class="headerlink" title="这篇文章用来学习markdown语法，这是二级标题。#H2"></a>这篇文章用来学习markdown语法，这是二级标题。#H2</h2><h3 id="这篇文章用来学习markdown语法，这是三级标题。-H3"><a href="#这篇文章用来学习markdown语法，这是三级标题。-H3" class="headerlink" title="这篇文章用来学习markdown语法，这是三级标题。#H3"></a>这篇文章用来学习markdown语法，这是三级标题。#H3</h3><h4 id="其实切换起来多加几个-号就可以了，这里是四级标题。-H4"><a href="#其实切换起来多加几个-号就可以了，这里是四级标题。-H4" class="headerlink" title="其实切换起来多加几个#号就可以了，这里是四级标题。#H4"></a>其实切换起来多加几个#号就可以了，这里是四级标题。#H4</h4><hr>
<h1 id="二：正文："><a href="#二：正文：" class="headerlink" title="二：正文："></a>二：正文：</h1><p>这样直接写就是正文。<br>末尾添加多余两个空格再回车，实现创建换行</p>
<p>换了一行<br>又换了一行   </p>
<p>空一行，换了一段。（换行换段我这里自动识别了）</p>
<hr>
<h1 id="三：加粗，斜体，斜体加粗，删除线："><a href="#三：加粗，斜体，斜体加粗，删除线：" class="headerlink" title="三：加粗，斜体，斜体加粗，删除线："></a>三：加粗，斜体，斜体加粗，删除线：</h1><p><strong>tips：（ctl+shift+home是选中当前行鼠标前内容，end当前行末，home当前行首）</strong></p>
<h3 id="加粗："><a href="#加粗：" class="headerlink" title="加粗："></a>加粗：</h3><p>加粗前后各（** ）包住</p>
<p><strong>markdown部分：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**我现在变粗体了**</span></span><br><span class="line"><span class="strong">**也可也ctl+b加粗**</span></span><br></pre></td></tr></table></figure>
<p><strong>渲染效果：</strong><br><strong>我现在变粗体了</strong><br><strong>也可也ctl+b加粗</strong></p>
<hr>
<h3 id="斜体，斜体加粗："><a href="#斜体，斜体加粗：" class="headerlink" title="斜体，斜体加粗："></a>斜体，斜体加粗：</h3><p>斜体前后各（* )包住<br>斜体并加粗就是前后各(*** )包住</p>
<p><strong>markdown部分：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*我现在歪了*</span>   //斜体</span><br><span class="line"><span class="strong">**<span class="emphasis">*也可也ctl+i选中变成斜体，然后再ctl+b加粗*</span>**</span> //<span class="strong">**<span class="emphasis">*这样三个是斜体加粗</span></span></span><br></pre></td></tr></table></figure>

<p><strong>渲染效果：</strong><br><em>我现在歪了</em><br><em><strong>也可也ctl+i选中变成斜体</strong></em></p>
<hr>
<h3 id="删除线："><a href="#删除线：" class="headerlink" title="删除线："></a>删除线：</h3><p>要加删除线的文字左右分别用两个~~号包起来</p>
<p><strong>markdown部分：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">~~我被杠掉了~~</span><br></pre></td></tr></table></figure>
<p><strong>渲染效果：</strong><br><del>我被杠掉了</del></p>
<hr>
<h1 id="四：引用，分割线："><a href="#四：引用，分割线：" class="headerlink" title="四：引用，分割线："></a>四：引用，分割线：</h1><p>引用：在引用的文字前加&gt;就行。引用也可以嵌套，只要不断&gt;&gt;&gt;&gt;&gt;&gt;就行。<br>分割线：分割线就是三个或以上的-或者*</p>
<p><strong>markdown部分：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br><span class="line"><span class="section">---                          //分割线</span></span><br><span class="line"><span class="section">----</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*                          //分割线</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span>**</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure>
<p><strong>渲染效果：</strong></p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<hr>
<hr>
<hr>
<hr>
<hr>
<h1 id="五：序号，段落小圆点："><a href="#五：序号，段落小圆点：" class="headerlink" title="五：序号，段落小圆点："></a>五：序号，段落小圆点：</h1><p><strong>markdown部分：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">   1.</span> 这样是有序，（1.+空格），换行会自动添加第二个序号</span><br><span class="line"><span class="bullet">   2.</span> 这样就有第二个序号</span><br><span class="line"><span class="bullet">   3.</span> - 第三行打个这样形式的</span><br><span class="line"><span class="bullet">      1.</span> tab，二级序号</span><br><span class="line"><span class="bullet">      2.</span> 二级序号第二个</span><br><span class="line"><span class="bullet">      3.</span> 二级序号第三个</span><br><span class="line"><span class="bullet">      4.</span> 第四</span><br><span class="line"><span class="code">          如果直接换一行，换行是这样的。</span></span><br><span class="line"><span class="code">如果这样加一些文字，即使没有缩进，渲染出来也还会是在二级序号的段落内</span></span><br><span class="line"><span class="code">         1. 三级序号</span></span><br><span class="line"><span class="code">         66. 如果乱打序号，渲染出来的序号其实还会是正确的。比如这一行打的66，渲染还会是2号</span></span><br><span class="line"><span class="code">         - 这样打是个小圆点点（-加一个空格）</span></span><br><span class="line"><span class="code">         - 换行会自动给你补全这个小圆点</span></span><br><span class="line"><span class="code">         </span></span><br></pre></td></tr></table></figure>
<p><strong>渲染效果：</strong></p>
<ol>
<li>这样是有序，（1.+空格），换行会自动添加第二个序号</li>
<li>这样就有第二个序号</li>
<li><ul>
<li>第三行打个这样形式的</li>
</ul>
<ol>
<li>tab，二级序号</li>
<li>二级序号第二个</li>
<li>二级序号第三个</li>
<li>第四<br> 如果直接换一行，换行是这样的。<br>如果这样加一些文字，即使没有缩进，渲染出来也还会是在二级序号的段落内<ol>
<li>三级序号</li>
<li>如果乱打序号，渲染出来的序号其实还会是正确的。比如这一行打的66，渲染还会是2号</li>
</ol>
<ul>
<li>这样打是个小圆点点（-加一个空格）</li>
<li>换行会自动给你补全这个小圆点</li>
</ul>
</li>
</ol>
</li>
</ol>
<hr>
<h1 id="六：添加图片："><a href="#六：添加图片：" class="headerlink" title="六：添加图片："></a>六：添加图片：</h1><p><strong>网络图片链接：</strong><br>ctl+alt+v，粘贴从在线网页上复制的内容，使用了拓展包，所以默认会加载到正在编辑的markdown的文件夹下<br>网络图片可以直接使用它的链接（不过网络图片连接很可能不知道啥时候就挂了，我自己用的图床是阿里云OSS，先测试几个月看看效果）</p>
<p><strong>markdown源码（此图片来自网络，如侵权，可联系删除）：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">beishangwa</span>](<span class="link">https://img.zcool.cn/community/0121c859e056fea80121ae0c405fd6.jpg@1280w_1l_2o_100sh.jpg</span>)</span><br></pre></td></tr></table></figure>
<p>下面的图就是网页上copy下来的悲伤蛙渲染效果。使用 ![]() 来链接图片。</p>
<p><img src="https://img.zcool.cn/community/0121c859e056fea80121ae0c405fd6.jpg@1280w_1l_2o_100sh.jpg" alt="beishangwa"></p>
<p><strong>本地图片链接方式：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](<span class="link">./beishangwa.png</span>)</span><br></pre></td></tr></table></figure>
<p>如果这样的话就可以使用本地的悲伤蛙（找不到路径需要.&#x2F;一下，vs可以识别路径里的图，这里估计会挂，我本地应该不在这个路径，建议放在相应的md文件夹内方便定义路径）</p>
<hr>
<h1 id="七：转义字符："><a href="#七：转义字符：" class="headerlink" title="七：转义字符："></a>七：转义字符：</h1><p><strong>markdown部分：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| character | name     |</span><br><span class="line">| --------- | -------- |</span><br><span class="line">| \\        | 反斜杠   |</span><br><span class="line">| \`        | 反引号   |</span><br><span class="line">| \<span class="emphasis">*        | 星号     |</span></span><br><span class="line"><span class="emphasis">| \_        | 下划线   |</span></span><br><span class="line"><span class="emphasis">| \&#123;\&#125;      | 大括号   |</span></span><br><span class="line"><span class="emphasis">| \[\]      | 中括号   |</span></span><br><span class="line"><span class="emphasis">| \(\)      | 小括号   |</span></span><br><span class="line"><span class="emphasis">| \#        | 井号     |</span></span><br><span class="line"><span class="emphasis">| \+        | 加号     |</span></span><br><span class="line"><span class="emphasis">| \-        | 减号     |</span></span><br><span class="line"><span class="emphasis">| \.        | 英文句号 |</span></span><br><span class="line"><span class="emphasis">| \!        | 感叹号   |</span></span><br></pre></td></tr></table></figure>
<p><strong>渲染效果：</strong></p>
<table>
<thead>
<tr>
<th>character</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>反斜杠</td>
</tr>
<tr>
<td>`</td>
<td>反引号</td>
</tr>
<tr>
<td>*</td>
<td>星号</td>
</tr>
<tr>
<td>_</td>
<td>下划线</td>
</tr>
<tr>
<td>{}</td>
<td>大括号</td>
</tr>
<tr>
<td>[]</td>
<td>中括号</td>
</tr>
<tr>
<td>()</td>
<td>小括号</td>
</tr>
<tr>
<td>#</td>
<td>井号</td>
</tr>
<tr>
<td>+</td>
<td>加号</td>
</tr>
<tr>
<td>-</td>
<td>减号</td>
</tr>
<tr>
<td>.</td>
<td>英文句号</td>
</tr>
<tr>
<td>!</td>
<td>感叹号</td>
</tr>
</tbody></table>
<hr>
<h1 id="八：表格"><a href="#八：表格" class="headerlink" title="八：表格"></a>八：表格</h1><p>(源码在vs显示的格式化修改：alt+shift+f)<br>表格中均默认左对齐，右对齐使用—后加：，或者居中对齐使用—前后各：：</p>
<p><strong>markdown部分：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">##### 左对齐：</span></span><br><span class="line">| 姓名   | 颜色 | 种族类型 |</span><br><span class="line">| ------ | ---- | -------- |</span><br><span class="line">| 悲伤蛙 | 绿   | 蛙子     |</span><br><span class="line">| 哈士奇 | 黑白 | 狗子     |</span><br><span class="line"></span><br><span class="line"><span class="section">##### 右对齐：</span></span><br><span class="line">| 姓名   | 颜色 | 种族类型 |</span><br><span class="line">| ------ | ---: | -------: |</span><br><span class="line">| 悲伤蛙 |   绿 |     蛙子 |</span><br><span class="line">| 哈士奇 |   黑 |     狗子 |</span><br><span class="line"></span><br><span class="line"><span class="section">##### 居中对齐：</span></span><br><span class="line">| 姓名   | 颜色  | 种族类型 |</span><br><span class="line">| ------ | :---: | :------: |</span><br><span class="line">| 悲伤蛙 |  绿   |   蛙子   |</span><br><span class="line">| 哈士奇 |  黑   |   狗子   |</span><br></pre></td></tr></table></figure>


<p><strong>渲染效果：</strong></p>
<h5 id="左对齐："><a href="#左对齐：" class="headerlink" title="左对齐："></a>左对齐：</h5><table>
<thead>
<tr>
<th>姓名</th>
<th>颜色</th>
<th>种族类型</th>
</tr>
</thead>
<tbody><tr>
<td>悲伤蛙</td>
<td>绿</td>
<td>蛙子</td>
</tr>
<tr>
<td>哈士奇</td>
<td>黑白</td>
<td>狗子</td>
</tr>
</tbody></table>
<h5 id="右对齐："><a href="#右对齐：" class="headerlink" title="右对齐："></a>右对齐：</h5><table>
<thead>
<tr>
<th>姓名</th>
<th align="right">颜色</th>
<th align="right">种族类型</th>
</tr>
</thead>
<tbody><tr>
<td>悲伤蛙</td>
<td align="right">绿</td>
<td align="right">蛙子</td>
</tr>
<tr>
<td>哈士奇</td>
<td align="right">黑</td>
<td align="right">狗子</td>
</tr>
</tbody></table>
<h5 id="居中对齐："><a href="#居中对齐：" class="headerlink" title="居中对齐："></a>居中对齐：</h5><table>
<thead>
<tr>
<th>姓名</th>
<th align="center">颜色</th>
<th align="center">种族类型</th>
</tr>
</thead>
<tbody><tr>
<td>悲伤蛙</td>
<td align="center">绿</td>
<td align="center">蛙子</td>
</tr>
<tr>
<td>哈士奇</td>
<td align="center">黑</td>
<td align="center">狗子</td>
</tr>
</tbody></table>
<hr>
<h1 id="九：正文对齐方式："><a href="#九：正文对齐方式：" class="headerlink" title="九：正文对齐方式："></a>九：正文对齐方式：</h1><p>markdown我查了一下好像是没有对齐的，但是它基本支持html的语法，所以我们可以写成：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">**居中对齐：**</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span>帅哥美女一键三连<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"></span><br><span class="line">**左对齐：**</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">&quot;left&quot;</span>&gt;</span>帅哥美女一键三连<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">**右对齐：**</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">&quot;right&quot;</span>&gt;</span>帅哥美女一键三连<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>渲染效果：</strong></p>
<p><strong>居中对齐：</strong></p>
<center>帅哥美女一键三连</center>

<p><strong>左对齐：</strong></p>
<p align="left">帅哥美女一键三连</p>

<p><strong>右对齐：</strong></p>
<p align="right">帅哥美女一键三连</p>

<hr>
<h1 id="十：插入链接"><a href="#十：插入链接" class="headerlink" title="十：插入链接"></a>十：插入链接</h1><p>还是ctl + C 然后选中需要添加链接的文字ctl + V<br>这是一个<a href="https://markdown.com.cn/basic-syntax/">markdown语法</a>链接</p>
<hr>
<h1 id="十一：代码框"><a href="#十一：代码框" class="headerlink" title="十一：代码框"></a>十一：代码框</h1><p>代码前后使用&#96;&#96;&#96;包裹,并指定一种语言</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\  <span class="code">```markdown</span></span><br><span class="line"><span class="code">      中间是内容</span></span><br><span class="line"><span class="code">\  ```</span></span><br></pre></td></tr></table></figure>

<p><strong>渲染效果：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">中间是内容</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="十二-hexo内插入网页视频"><a href="#十二-hexo内插入网页视频" class="headerlink" title="十二: hexo内插入网页视频"></a>十二: hexo内插入网页视频</h1><h5 id="目前是使用raw的方式：（markdown应该不可以直接渲染预览，但是hexo是支持的，自适应方面还阔以）"><a href="#目前是使用raw的方式：（markdown应该不可以直接渲染预览，但是hexo是支持的，自适应方面还阔以）" class="headerlink" title="目前是使用raw的方式：（markdown应该不可以直接渲染预览，但是hexo是支持的，自适应方面还阔以）"></a>目前是使用raw的方式：（markdown应该不可以直接渲染预览，但是hexo是支持的，自适应方面还阔以）</h5><p><strong>markdown部分：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">iframe</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=939470868&amp;bvid=BV1VT4y1B7QL&amp;cid=731375438&amp;page=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: absolute; width: 100%; </span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">height: 100%; left: 0; top: 0;&quot;</span>&gt;</span></span> <span class="language-xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>渲染效果：</strong></p>


<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe 
src="//player.bilibili.com/player.html?aid=939470868&bvid=BV1VT4y1B7QL&cid=731375438&page=1" scrolling="no" border="0" 
frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; 
height: 100%; left: 0; top: 0;"> </iframe></div>



<hr>
<h1 id="十三-emoji"><a href="#十三-emoji" class="headerlink" title="十三: emoji"></a>十三: emoji</h1><p>推荐网站<a href="https://emojipedia.org/">emojipedia</a><br>直接复制粘贴就好，可以正确渲染<br>示例：<br>🍇<br>🐗<br>🙃<br>🗻</p>
<hr>
<p>当然，也可以使用 <a href="https://unicode.org/emoji/charts/full-emoji-list.html">full emoji list</a><br>格式：<code>&amp;#x  +unicode + ;</code></p>
<p>范例：<br><code>&amp;#x1F601;</code><br><code>&amp;#x1F602;</code></p>
<p>渲染效果：<br>&amp;#x1F601;<br>&amp;#x1F602;</p>
<hr>
<h1 id="十四-图床"><a href="#十四-图床" class="headerlink" title="十四: 图床"></a>十四: 图床</h1><p>我配置的是阿里云OSS + PicGo + vscode的方案<br>由于我的编辑器是vscode，所以在vscode上传图片的快捷键如下：</p>
<p>上传截图：ctl+alt+u</p>
<hr>
<p><strong><center>待续，学到后再加</center></strong></p>
]]></content>
      <categories>
        <category>-Markdown</category>
      </categories>
      <tags>
        <tag>-学习</tag>
      </tags>
  </entry>
  <entry>
    <title>3Blue1Brown_线代本质第一章：向量究竟是什么</title>
    <url>/2022/09/22/math_Essense_of_Linear_Algebra_P01/</url>
    <content><![CDATA[<h1 id="3Blue1Brown-线代本质第一章：向量究竟是什么"><a href="#3Blue1Brown-线代本质第一章：向量究竟是什么" class="headerlink" title="3Blue1Brown_线代本质第一章：向量究竟是什么"></a>3Blue1Brown_线代本质第一章：向量究竟是什么</h1><ul>
<li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li>
<li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li>
<li>官方一共将此系列分为12节，所以我也会分开写。</li>
<li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li>
<li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li>
</ul>
<hr>
<h2 id="✏️向量基本解释："><a href="#✏️向量基本解释：" class="headerlink" title="✏️向量基本解释："></a>✏️向量基本解释：</h2><ul>
<li><strong>在线性代数中，最基础，最根源的组成部分就是向量</strong></li>
<li><strong>一般来说，有三种看待向量的观点，他们看似不同却有所关联。</strong><ul>
<li>物理专业的角度</li>
<li>数学角度</li>
<li>计算机角度</li>
</ul>
</li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/vector.png" alt="vector"></p>
<hr>
<h3 id="📝物理专业的角度："><a href="#📝物理专业的角度：" class="headerlink" title="📝物理专业的角度："></a>📝物理专业的角度：</h3><ul>
<li><strong>向量是空间中的箭头。</strong></li>
<li>决定一个向量的是：<ol>
<li>它的长度。</li>
<li>它所指的方向。</li>
</ol>
</li>
<li>只要上述两个特征不改变，就可以自由移动一个向量而保持它本身不被改变。</li>
<li>处在平面中的向量是二维的。</li>
<li>处在生活空间中的向量是三维的。</li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/2vs3Dimensional.png" alt="2vs3Dimensional"></p>
<hr>
<h3 id="📝计算机角度："><a href="#📝计算机角度：" class="headerlink" title="📝计算机角度："></a>📝计算机角度：</h3><ul>
<li><strong>向量是有序的数字列表。</strong></li>
<li>比如你正在做一个有关房价的分析，你关心的只有两个特征：<ol>
<li>房屋面积。</li>
<li>房屋价格。</li>
</ol>
</li>
<li>注意数字列表的<strong>数字顺序不可颠倒</strong></li>
<li>在这个房屋的例子里可以表述为：用二维向量对房屋进行建模。</li>
<li>在这里，向量只不过是列表的一个花哨的说法，这个向量是二维的因为它的列表长度是2。</li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/cs_vector.png" alt="csStudent_vector"></p>
<hr>
<h3 id="📝数学角度："><a href="#📝数学角度：" class="headerlink" title="📝数学角度："></a>📝数学角度：</h3><ul>
<li><strong>向量可以是任何东西，只要保证两个向量相加以及数字与向量相乘是有意义的即可。</strong></li>
<li>这种方式看待向量就较为抽象了。这里可以看出，向量加法和向量数乘贯穿线性代数，二者起着很重要的作用。</li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/math_vector.png" alt="math_vector"></p>
<hr>
<h2 id="✏️向量思考方式："><a href="#✏️向量思考方式：" class="headerlink" title="✏️向量思考方式："></a>✏️向量思考方式：</h2><ul>
<li>首先考虑一个坐落在某个坐标系（例如x-y平面）中的箭头，箭头起点位于原点。</li>
<li>在线性代数中，向量经常以原点作为起点；这与物理学理念（向量可以在空间中自由落脚）不同。</li>
<li>一旦理解了【向量是空间中的箭头】，那么我们可以通过【向量坐标】来理解【向量是一个有序数字列表】</li>
<li>因为这两种观念的碰撞，恰恰形成了线性代数中的重要概念。</li>
</ul>
<hr>
<h3 id="📝平面空间内："><a href="#📝平面空间内：" class="headerlink" title="📝平面空间内："></a>📝平面空间内：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/vector%E5%B9%B3%E9%9D%A2%E7%A9%BA%E9%97%B4.png" alt="vector平面空间"></p>
<ul>
<li>来看这个箭头在x-y平面空间内（每个间距单位为1），它的这对数指导我们如何从原点（向量起点）出发到达它的尖端（向量终点）。</li>
<li>第一个数告诉我们沿着x轴走多远，正数代表向右移动，负数代表向左移动。</li>
<li>第二个数告诉我们沿着y轴走多远。正数代表向上移动，负数代表向下移动。</li>
<li>为了把向量和点区别开，向量采用的写法是将这对数竖着写，并用方括号括起来。（（-2，3）这样表示的向量也是可以的，没有区别）。</li>
<li>每一对数给出为一一个向量（有且只有一个）。</li>
<li>每一个向量恰好对应为一一对数。</li>
</ul>
<hr>
<h3 id="📝三维空间内："><a href="#📝三维空间内：" class="headerlink" title="📝三维空间内："></a>📝三维空间内：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E5%90%91%E9%87%8F1.png" alt="三维空间向量1"></p>
<ul>
<li>三维空间内我们再添加一个垂直于x轴和y轴的第三根z轴</li>
<li>这种情况下，每个向量就与一个有序的三元数组对应。</li>
<li>第一个数告诉你沿平行x轴走多远，第二个数告诉你沿平行y轴走多远，第三个数告诉你沿平行z轴走多远。</li>
<li>每个三元数组给出为一一个向量。</li>
<li>每个向量对应唯一的三元数组。</li>
</ul>
<hr>
<h3 id="📝向量加法和向量数乘："><a href="#📝向量加法和向量数乘：" class="headerlink" title="📝向量加法和向量数乘："></a>📝向量加法和向量数乘：</h3><ul>
<li>线性代数中每一个主题都围绕着这两种运算。</li>
</ul>
<h4 id="✍️向量加法："><a href="#✍️向量加法：" class="headerlink" title="✍️向量加法："></a>✍️向量加法：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/vectorSum.png" alt="vectorSum"></p>
<ul>
<li>向量加法：<ul>
<li>我们通过平移第二个向量，使他的起点与第一个向量的终点重合；然后画一个向量，它从第一个向量的起点出发，指向第二个向量的终点；这个向量就是他们的和</li>
</ul>
</li>
<li>向量加法的定义差不多是线代中唯一允许向量离开原点的情形。</li>
<li>我们可以把向量加法看作数轴上加法的一种扩展。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E6%95%B0%E8%BD%B4%E5%8A%A0%E6%B3%95.png" alt="数轴加法"></li>
<li>回到x-y平面内，我们可以以下图方式所思考向量的加法，即：它朝着x轴，y轴分别运动的总量；先完成它水平运动，再完成竖直运动。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%90%91%E9%87%8F%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97%E6%96%B9%E5%BC%8F.png" alt="向量加法运算方式"></li>
</ul>
<hr>
<h4 id="✍️向量数乘："><a href="#✍️向量数乘：" class="headerlink" title="✍️向量数乘："></a>✍️向量数乘：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%90%91%E9%87%8F%E6%95%B0%E4%B9%98.png" alt="向量数乘"></p>
<ul>
<li>向量与其他数（标量）相乘的方式叫做“Scaling”（缩放）。</li>
<li>数字（标量）在线性代数的作用就是缩放向量；负数与向量相乘则会改变向量的方向。</li>
</ul>
<hr>
<h3 id="📝总结："><a href="#📝总结：" class="headerlink" title="📝总结："></a>📝总结：</h3><ul>
<li><strong>怎么看待向量都无所谓，它的实际作用也很少体现在这些观点的其中一个上，而是更多的体现在它能够在这些观点中相互转化。</strong></li>
<li>线性代数为数据分析提供了一条将大量数据列表概念化，可视化的渠道。他让数据样式变得非常明晰，并让我们了解特定运算的意义。</li>
<li>另一方面，线代给物理学家和计算机图形程序员提供了一种语言，让他们通过计算机能处理的数字来描述并操纵空间。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>-3Blue1Brown线性代数本质</category>
      </categories>
      <tags>
        <tag>-学数学</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4官方材质课_基础篇</title>
    <url>/2022/09/13/ue_MatClass_foundation/</url>
    <content><![CDATA[<p>🐸本文为虚幻官方材质课的学习记录，并不完全，在此按我的个人需求记录了如下笔记。<strong>这一篇是基础篇</strong>。<br>🐸这里是基础篇<a href="https://www.bilibili.com/video/BV1fX4y1N7Fw?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接</a><br>🐸这里是高级篇<a href="https://www.bilibili.com/video/BV1sy4y127HZ/?spm_id_from=333.788.video.desc.click&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接</a><br>🐸<strong>加油 ！ 加油 ！</strong></p>
<hr>
<h1 id="UE4官方材质课-基础篇"><a href="#UE4官方材质课-基础篇" class="headerlink" title="UE4官方材质课_基础篇"></a>UE4官方材质课_基础篇</h1><h2 id="一：了解材质："><a href="#一：了解材质：" class="headerlink" title="一：了解材质："></a>一：了解材质：</h2><h3 id="🚩PBR（Physically-Based-Rendering）："><a href="#🚩PBR（Physically-Based-Rendering）：" class="headerlink" title="🚩PBR（Physically-Based Rendering）："></a>🚩PBR（Physically-Based Rendering）：</h3><p>基于物理的渲染。<br>它提供了一种光照和渲染方法，能够更精确的描绘光和表面之间的作用。<br>PBR流程能更真实的模拟光照和材质之间的物理交互效果。</p>
<ul>
<li>直观便于理解</li>
<li>物理上更具准确性<ul>
<li>pbr基于物理定律，如能量守恒定律和平方反比定律(Inverse-square law)</li>
<li>pbr材质在不同的光照下会表现的更一致</li>
</ul>
</li>
<li>使用真实的物理测量单位表示亮度<ul>
<li>Lumens(流明),Lux（勒克斯）</li>
</ul>
</li>
</ul>
<p>💡简单来说基于物理的渲染本质上是通过：</p>
<ul>
<li>材质</li>
<li>灯光</li>
<li>曝光</li>
</ul>
<p>这三大部分控制的组合结果。</p>
<h3 id="🚩Primary-PBR-Inputs："><a href="#🚩Primary-PBR-Inputs：" class="headerlink" title="🚩Primary PBR Inputs："></a>🚩Primary PBR Inputs：</h3><ul>
<li>Base col</li>
<li>Metallic</li>
<li>Specular</li>
<li>Roughness</li>
</ul>
<h4 id="🏕️Base-color（Albedo）"><a href="#🏕️Base-color（Albedo）" class="headerlink" title="🏕️Base color（Albedo）"></a>🏕️Base color（Albedo）</h4><ul>
<li>flat color,没有任何光照信息（没有高光和阴影）</li>
<li>只保存颜色信息</li>
<li>可以是linear RGB，也可也是一个Vector3</li>
<li>各个通道的数值位于0到1之间（纯白和纯黑会导致一些场景的曝光问题）</li>
</ul>
<h4 id="🏕️Metalic"><a href="#🏕️Metalic" class="headerlink" title="🏕️Metalic"></a>🏕️Metalic</h4><ul>
<li>Gray scale</li>
<li>数值在0 到 1的区间,不包含任何色彩信息</li>
<li>金属最正确的设置方式是全开或全关<ul>
<li>数值为0时，材质底色是diffuse</li>
<li>数值为1时，材质底色是specular&#x2F;reflection color</li>
<li>示例图：<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/metallic.png" alt="metallic"></li>
</ul>
</li>
</ul>
<h4 id="🏕️Roughness"><a href="#🏕️Roughness" class="headerlink" title="🏕️Roughness"></a>🏕️Roughness</h4><ul>
<li>Gray scale</li>
<li>数值在0 到 1的区间,不包含任何色彩信息<ul>
<li>数值为0时，无限接近于镜面反射</li>
<li>数值为1时，为粗糙表面</li>
</ul>
</li>
</ul>
<p>粗糙度是能量守恒的体现。</p>
<h4 id="🏕️Specular"><a href="#🏕️Specular" class="headerlink" title="🏕️Specular"></a>🏕️Specular</h4><ul>
<li>控制高光和反射（specular highlights and reflections）</li>
<li>Gray scale</li>
<li>一般情况下保持default value 0.5就可以了</li>
<li>通常情况下，我们通过调整Roughness来调整高光质感</li>
<li>正常世界中，所有物体都有一定程度的反射和高光效果</li>
</ul>
<p>示例图：<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/roughness.png" alt="roughness"></p>
<h3 id="🚩UE支持的图片文件的格式（常用）："><a href="#🚩UE支持的图片文件的格式（常用）：" class="headerlink" title="🚩UE支持的图片文件的格式（常用）："></a>🚩UE支持的图片文件的格式（常用）：</h3><table>
<thead>
<tr>
<th>未压缩格式</th>
<th>压缩格式</th>
</tr>
</thead>
<tbody><tr>
<td>BMP</td>
<td>PNG（simple Alpha）</td>
</tr>
<tr>
<td>TGA（Alpha）</td>
<td>JPG</td>
</tr>
<tr>
<td>PSD</td>
<td>DDS</td>
</tr>
<tr>
<td></td>
<td>HDR</td>
</tr>
</tbody></table>
<ul>
<li>simple Alpha通常被用于植被</li>
</ul>
<h3 id="🚩贴图规则："><a href="#🚩贴图规则：" class="headerlink" title="🚩贴图规则："></a>🚩贴图规则：</h3><ul>
<li>最大支持8k</li>
<li>长宽必须是2的指数幂（512，1024，2048）</li>
<li>roughness，metallic，specular均不需要rgb通道，所以直接储存为gray scale导入UE。这样他们就会被自动设置成灰度图，并且不会启动sRGB或者Linear的颜色空间</li>
<li>Normal 贴图也同理，不需要使用sRGB</li>
<li>HDR 也不需要使用sRGB，因为它的取值一般会超出范围</li>
<li>sRGB只适用于颜色贴图（导入需要确保灰度图没有勾选sRGB）</li>
<li>所有的灰度贴图只要储存形式正确，那么UE会直接自动设置为禁用sRGB</li>
<li>所有的base col应当将压缩格式设置为DXT1（在贴图设置选项中，compression也可以自行更改，如果格式正确，那么UE会自动为你设置好它的compression setting）</li>
</ul>
<h3 id="🚩贴图导入方式："><a href="#🚩贴图导入方式：" class="headerlink" title="🚩贴图导入方式："></a>🚩贴图导入方式：</h3><ul>
<li>直接拖入项目</li>
<li>右键在content browser选择import Assets</li>
</ul>
<h3 id="🚩UE材质编辑器tips："><a href="#🚩UE材质编辑器tips：" class="headerlink" title="🚩UE材质编辑器tips："></a>🚩UE材质编辑器tips：</h3><ul>
<li>双击节点之间的连线，创建dot整理节点</li>
<li>c，创建comment</li>
<li>ctl+拖动节点连线来改变节点连接输出的位置</li>
<li>clean up删除此节点图中的孤立节点（unused node）</li>
<li>connector改变节点显示方式</li>
<li>T，创建texture sample</li>
</ul>
<h3 id="🚩混合模式："><a href="#🚩混合模式：" class="headerlink" title="🚩混合模式："></a>🚩混合模式：</h3><p>在Material中，可以找到<strong>Blend Mode</strong>和<strong>Shading Mode</strong>这两项，这两项十分重要</p>
<h4 id="🍭Blend-Mode："><a href="#🍭Blend-Mode：" class="headerlink" title="🍭Blend Mode："></a>🍭Blend Mode：</h4><ul>
<li><strong>Opaque 不透明</strong><ul>
<li>多数不透明材质的基本设置</li>
</ul>
</li>
<li><strong>masked 遮罩</strong><ul>
<li>显示有mask遮罩的材质</li>
<li>背面默认不显示，需要开启two sided</li>
</ul>
</li>
<li><strong>Translucent 半透明</strong><ul>
<li>通常使用在半透明材质，玻璃等有折射的材质</li>
<li>同时控制opacity与refraction来调整效果</li>
<li>Translucent一般情况下以最简单的方式计算半透明，以节约开销</li>
<li>如果想提升半透明材质的效果，需要来到Translucency的选项下，勾选Screen SPace Reflection，并把Lighting Mode改成Surface ForwardShading；这两个选项能让我们获得最高质量的半透明材质。开启这两个选项后，着色器需要更长的时间编译。</li>
</ul>
</li>
<li><strong>additive 叠加</strong></li>
<li><strong>Modulate 调制</strong></li>
<li><strong>AlphaComposite（Premultiplied Alpha） alpha复合（预乘Alpha）</strong></li>
</ul>
<p><strong>Translucent：</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/blendMode_Translucent.png" alt="blendMode_Translucent"></p>
<h4 id="🍭Shading-Mode："><a href="#🍭Shading-Mode：" class="headerlink" title="🍭Shading Mode："></a>🍭Shading Mode：</h4><ul>
<li><strong>Default Lit</strong><ul>
<li>通常的光照设置，材质受光照影响</li>
</ul>
</li>
<li><strong>Unlit</strong><ul>
<li>材质不受光照影响；这种模式下允许表面产生自发光</li>
</ul>
</li>
<li><strong>subsurface</strong><ul>
<li>次表面散射，如皮肤和蜡烛</li>
</ul>
</li>
<li><strong>clear coat</strong></li>
<li><strong>two sided foliage</strong></li>
<li><strong>hair</strong></li>
<li><strong>cloth</strong></li>
<li><strong>eye</strong></li>
</ul>
<h5 id="🍌subsurface-scattering"><a href="#🍌subsurface-scattering" class="headerlink" title="🍌subsurface scattering"></a>🍌subsurface scattering</h5><ul>
<li>将Material的shading mode设置为subsurface</li>
<li>主要使用两个矢量（base color和subsurface color）和两个标量（opacity和roughness）</li>
</ul>
<p>示例：<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/subsurfaceMat.png" alt="subsurfaceMat"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/subsurface.png" alt="subsurface"></p>
<h3 id="🚩创建一个简单材质："><a href="#🚩创建一个简单材质：" class="headerlink" title="🚩创建一个简单材质："></a>🚩创建一个简单材质：</h3><ul>
<li>当我们给mesh更换材质，或应用新材质时，需要在静态网格编辑器（Static Mesh Editor）中打开mesh，并且在右侧Detail面板下更换指定新材质</li>
<li>UE支持多材质对象。一个mesh可以有多个elements并指定材质</li>
<li>最好遵从材质命名规则，如Material最好以<strong>M_name</strong>这样以M为前缀来开头</li>
<li>T for texture sample，选择我们需要的贴图</li>
<li>基础材质创建使用的大多数是：base col， roughness， normal</li>
</ul>
<h3 id="🚩继续简单材质："><a href="#🚩继续简单材质：" class="headerlink" title="🚩继续简单材质："></a>🚩继续简单材质：</h3><ul>
<li><p>如果希望在贴图中预览并使用到UE的content，则需要再texture的选项里打开<strong>show Engine Content</strong></p>
<ul>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/showUEcontent.png" alt="showUEcontent"></li>
</ul>
</li>
<li><p><strong>反转黑白可以使用（1-x）One Minus</strong></p>
</li>
<li><p><strong>混合：Multiply（M）</strong></p>
</li>
<li><p><strong>相加：Add（A</strong>）</p>
</li>
<li><p>使用constant与贴图Multiply，以达到控制灰度的效果，或使贴图与相应选区进行混合</p>
</li>
<li><p><strong>常用噪波：perlin noise</strong></p>
</li>
<li><p><strong>线性插值：Lerp</strong></p>
<ul>
<li>利用alpha通道混合a，b两个图层</li>
</ul>
</li>
<li><p><strong>常用扁平法线：flatnormal</strong></p>
</li>
<li><p><strong>平铺纹理：Texture Coordinate</strong></p>
</li>
</ul>
<h3 id="🚩使用DataSmith从其他DCC软件导入材质到UE："><a href="#🚩使用DataSmith从其他DCC软件导入材质到UE：" class="headerlink" title="🚩使用DataSmith从其他DCC软件导入材质到UE："></a>🚩使用DataSmith从其他DCC软件导入材质到UE：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/vraytoUE_datasmith.png" alt="vraytoUE_datasmith"><br>简单解释就是其他的软件制作好的材质会被以一种datasmith提供的方式转换到ue中，但是有些情况下是无法正确转换的。需要额外自行修正，并且灯光也不会被预先烘培。</p>
<hr>
<h2 id="二：创建PBR材质（基础）"><a href="#二：创建PBR材质（基础）" class="headerlink" title="二：创建PBR材质（基础）"></a>二：创建PBR材质（基础）</h2><h3 id="🚩主材质实例："><a href="#🚩主材质实例：" class="headerlink" title="🚩主材质实例："></a>🚩主材质实例：</h3><ul>
<li>实例化材质可以为我们的主材质创建副本，然后用来代替主材在项目中使用</li>
<li>实例化材质的优点：<br>  1.节约时间，可以通过公开主材质的某些参数，进一步调整实例材质而无需重新编译着色器。<br>  2.对主材质进行的改动也会更新到所有的材质实例。<br>  3.仅需要根据材质特性创建主材质，然后实例化材质应用到所有的类似材质上。</li>
</ul>
<h3 id="🚩公开材质参数："><a href="#🚩公开材质参数：" class="headerlink" title="🚩公开材质参数："></a>🚩公开材质参数：</h3><ul>
<li>右键相应节点，convert to parameter并重命名</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/convertParam.png" alt="convertParam"></li>
</ul>
<h3 id="🚩switch："><a href="#🚩switch：" class="headerlink" title="🚩switch："></a>🚩switch：</h3><ul>
<li><strong>Static Switch Parameter</strong>，静态开关参数</li>
<li>使我们开启或禁用某些功能<br><strong>示例：</strong><br>当True的时候，开启base color与纯色相乘，为False时则关闭相乘，仅显示base color<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/swichPara.png" alt="swichPara"></li>
</ul>
<h3 id="🚩实例材质的优先级以及参数最大最小值："><a href="#🚩实例材质的优先级以及参数最大最小值：" class="headerlink" title="🚩实例材质的优先级以及参数最大最小值："></a>🚩实例材质的优先级以及参数最大最小值：</h3><p><strong>当制作材质的时候，可以修改材质参数的优先级方便使用</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/groupandpior.png" alt="groupandpior"><br><strong>我们可以通过修改Group和sort Piriority来实现</strong></p>
<ul>
<li>只需要选中group中的“None”，将None改为我们需要的组名</li>
<li>sort Piriority为0的组会优先出现再我们的分组中，依次是1，2，3的组</li>
<li>分组需要按需求比如tex，utility，uv之类的功能不同的节点可以分开设置，并自行定义优先级</li>
</ul>
<p><strong>示例：</strong> 此时所有的参数就被归档在我们定义好的组中。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/groupPreview.png" alt="groupPreview"></p>
<p><strong>✏️可以给参数滑块设置最大最小值，使可以调节的范围不超过我们设定的值</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/minMax.png" alt="minMax"></p>
<h3 id="🚩动态材质："><a href="#🚩动态材质：" class="headerlink" title="🚩动态材质："></a>🚩动态材质：</h3><p><strong>材质一般在UE中分为两种：</strong></p>
<ol>
<li>静态材质</li>
<li>动态材质<ul>
<li>动态材质让我们在运行的时候实时调整</li>
</ul>
</li>
</ol>
<p><strong>Actor：</strong></p>
<ul>
<li>Actor与普通的mesh相比，它可以附加蓝图</li>
<li>我们需要在Event Graph中创建我们的功能</li>
<li>创建dynamic material，并在source Material中指定材质源</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/bpshaderball.png" alt="bpshaderball"></li>
<li>之后再set texture parameter value ，使用我们指定的参数Diffuse</li>
<li>再创建set scalar Parameter value， 控制Metallic</li>
<li>最后需要set vector parameter value，设置Color</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/bpshaderball2.png" alt="bpshaderball2"></li>
<li>因为我们或许希望color不会在创建出的时候即刻执行，我们希望用户再点击屏幕对象的时候改变这个参数，所以此时还需要“事件调度器（Event Dispatchers）”来完成它</li>
<li>此时需要先创建变量，再set color</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/bpvriable.png" alt="bpvriable"></li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/bpvriableType.png" alt="bpvriableType"></li>
<li>最后设置event Dispatchers，选择event。最后compile，此时编辑好了actor的材质。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/bpeventDisp2.png" alt="bpeventDisp2"></li>
</ul>
<h3 id="🚩编辑level-Blueprint："><a href="#🚩编辑level-Blueprint：" class="headerlink" title="🚩编辑level Blueprint："></a>🚩编辑level Blueprint：</h3><ul>
<li>现在要做事情使编辑关卡的蓝图，使我们之前编辑的actor生效，效果达到：点击之前编辑的actor，并使它颜色发生改变</li>
<li>进入level BP，创建get player controller，获取用户的动态，mouse cursor，click even看他是否对actor进行操作，然后再用事件调度器触发自定义事件</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lbp_clickeven.png" alt="lbp_clickeven"></li>
<li>接着我们要判断用户是否点击到了正确的对象 ，然后再触发自定义事件，完成颜色替换的指令</li>
<li>get hit result under cursor for object，然后确认object type，使用make Array，确认我们希望用户能够点击哪类对象。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lbp_clickeven2.png" alt="lbp_clickeven2"></li>
<li>接着left mouse button获取鼠标的动态，看右键是否点击到了正确的目标。</li>
<li>get class，class is child of，得到父类下正确的对象。如果结果是我们需要的对象，则返回True。</li>
<li>cast to ，通过这个引用我们可以访问之前用于改变颜色的自定义事件。</li>
<li>最后获取change color even，获取到我们之前定义的事件，并且设置随机颜色。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lbp_clickeven3.png" alt="lbp_clickeven3"></li>
<li>compile，play。这样我们自定义的actor就会随着鼠标点击随机改变颜色。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lbp_clickeven4.png" alt="lbp_clickeven4"></li>
</ul>
<h3 id="🚩材质参数集合，创建全局参数集（Parameter-Collection）："><a href="#🚩材质参数集合，创建全局参数集（Parameter-Collection）：" class="headerlink" title="🚩材质参数集合，创建全局参数集（Parameter Collection）："></a>🚩材质参数集合，创建全局参数集（Parameter Collection）：</h3><ul>
<li>有时候因为场景变化的需求，比如下雨天材质整体变得湿润，或者受到风力影响而相关材质摇曳的程度增强，或者自发光强度因为场景变化需要整体变强。</li>
<li>如果一个一个调整则很花费时间。此时就要用到材质参数集，达到批量修改整体参数的目的。</li>
<li>我们可以右键在content中创建Meterial Parameter Collection，再分别创建自己需要的全局标量和向量。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/mpc_setting.png" alt="mpc_setting"></li>
<li>在Master Mat中，建立collection parameter，选择之前创建的参数集，与需要修改的参数相乘。</li>
<li>如有float4的参数出现，则需要使用component Mask转换成float3，以免出现数据类型的不匹配</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/mpc_setting2.png" alt="mpc_setting2"></li>
<li><strong>全局参数集相当于给所有设置全局变量的参数一个总控制，每个单独的材质也可以在自己的材质球下独立调节，但是总集控制所有材质的全局参数，如果在总集禁用，那么独立的材质的那个参数也会被禁用。</strong></li>
</ul>
<h3 id="🚩材质参数集合，第二部分："><a href="#🚩材质参数集合，第二部分：" class="headerlink" title="🚩材质参数集合，第二部分："></a>🚩材质参数集合，第二部分：</h3><ul>
<li>现在想要实现：允许用户点击后，更改其中的一个全局参数</li>
<li>需要在level BluePrint里进行编辑，与Actor部分相似，前半部分判断鼠标点击以及获取用户行为的蓝图操作是一样的（在我的基础篇笔记上篇）</li>
<li>之后，判断点击对象，确保在视窗内选中正确对象然后 create reference带入蓝图</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/mpc__bpsetting.png" alt="mpc__bpsetting"></li>
<li>选择正确的目标进行判断，并设置好rendom vector。</li>
<li>compiled，此时play就会看见随着鼠标点击，全局对象也可以随机改变颜色了。</li>
</ul>
<h3 id="🚩材质函数："><a href="#🚩材质函数：" class="headerlink" title="🚩材质函数："></a>🚩材质函数：</h3><ul>
<li>材质函数就是材质图表中可以反复使用的自定义代码片段</li>
<li>它的好处是可以把复杂的材质图表转化成拥有单个输入输出的单个材质节点</li>
<li>更改代码中的函数，所有实例也会同步修改</li>
</ul>
<h4 id="✏️此时的案例要实现的是uv-tiling。"><a href="#✏️此时的案例要实现的是uv-tiling。" class="headerlink" title="✏️此时的案例要实现的是uv tiling。"></a>✏️此时的案例要实现的是uv tiling。</h4><ul>
<li>在content中创建Material Function，点击进去。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_func01.png" alt="m_func01"></li>
<li>如上图，我们首先设置uv 平铺，其次设置旋转，再判断使用不使用rotation</li>
<li>编辑好后需要单击面板，开启左侧列表中的“Expose to Library”，才能确保我们后续能正常搜索到它。</li>
<li>接下来回到我们需要使用tiling的材质</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_func01_tiling.png" alt="m_func01_tiling"></li>
<li>搜索我们之前创建的Function，并根据我们之前设置的变量来分别连接参数</li>
<li>此时这个材质就有UV Tiling的选项。</li>
</ul>
<p><strong>数据迁移：</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_func_Migrate.png" alt="m_func_Migrate"></p>
<ul>
<li>此方式能够将做好的材质函数迁移到其他文件使用</li>
<li>当然也可以通过这种方式迁移别的需要的资产</li>
</ul>
<h4 id="✏️另一种材质函数的方式：CustomNode"><a href="#✏️另一种材质函数的方式：CustomNode" class="headerlink" title="✏️另一种材质函数的方式：CustomNode"></a>✏️另一种材质函数的方式：CustomNode</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_customNode.png" alt="m_customNode"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_customN_name.png" alt="m_customN_name"></p>
<ul>
<li>这种方式通过hlsl语言来创建材质函数，得到自制的材质节点</li>
<li>设置的input name需要与code的名字匹配</li>
<li>定义hlsl并不像内置的材质表达式，且无法被优化</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_customN.png" alt="m_customN"></li>
</ul>
<hr>
<h2 id="三：实例创建不同的材质演示："><a href="#三：实例创建不同的材质演示：" class="headerlink" title="三：实例创建不同的材质演示："></a>三：实例创建不同的材质演示：</h2><h3 id="🚩clear-coat制作类似车漆质感："><a href="#🚩clear-coat制作类似车漆质感：" class="headerlink" title="🚩clear coat制作类似车漆质感："></a>🚩clear coat制作类似车漆质感：</h3><ul>
<li>将shading mode设置为clear coat后，Material会又clear coat和clear coat Roughness这两个选项</li>
<li>它的显示方式与普通的材质较为相似，如果希望有光滑的表面，并且希望透明图层下的表面有凹凸效果，就可以选择clear coat来模拟</li>
<li>如果要启用clear coat的第二层normal，则需要去setting中开启（默认是关闭的）</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/clearcoat_enableSecNormal.png" alt="clearcoat_enableSecNormal"></li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/btNormal.png" alt="btNormal"></li>
<li>我们可以lerp两个scaler控制roughness，并用类似的方式控制设置表面的normal以及clear coat光滑表面下的bottom normal</li>
<li><strong>示例：</strong></li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/clearcoatmat.png" alt="clearcoatmat"></li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/clearcoatmat_view.png" alt="clearcoatmat_view"></li>
</ul>
<h3 id="🚩Two-Sided-Foliage-双面植被："><a href="#🚩Two-Sided-Foliage-双面植被：" class="headerlink" title="🚩Two-Sided Foliage 双面植被："></a>🚩Two-Sided Foliage 双面植被：</h3><ul>
<li>masked这种模式需要与shading mode下双面材质（two sided foliage）设置配合使用。（如果是default lit的模式下，则没有subsurface通道）</li>
<li>这种着色方式实际上并不是半透明的，但他能很好的与蒙版混合模式搭配使用，并且借助subsurface color以更低的开销模拟半透明效果。</li>
<li>其他的材质通道设置与普通材质没有很大区别,要注意的是使用opacity mask并且需要双面显示的话，一定要勾上two sided这个选项。</li>
<li>借助wo Sided Texturing这个function可以分开控制双面材质正反两面的参数以及效果，最终的结果就是调节了subsurface以模拟光透过叶片的效果</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/twoSidedFunction.png" alt="twoSidedFunction"></li>
<li><strong>示例：</strong></li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/twoSidedFoliage.png" alt="twoSidedFoliage"></li>
</ul>
<h3 id="🚩布料着色："><a href="#🚩布料着色：" class="headerlink" title="🚩布料着色："></a>🚩布料着色：</h3><blockquote>
<p><strong>小tip</strong>：如果有时候近处被裁切影响放大观察，则可以去Output Log的cmd中输入：r.SetNearClipPlane 1,将相机近景裁切更改为1</p>
</blockquote>
<ul>
<li>通常我们可以使用subsurface或者fresnel来实现布料的模拟。但是UE提供的 shading mode下就有 cloth这个选项，该着色模式使模拟布料的时候可以用于不同角度查看它的毛绒质感</li>
<li>我们创建布料材质的时候，shading mode需要选择cloth，blend mode保持opaque；此时Material中就会有Fuzz color 和cloth这两个通道。cloth通道可以借助mask指定该材质哪些部分是布料。如果是窗帘这样需要双面的材质，则也需要勾选two sided。</li>
<li>可以通过两个texture sample将布料纹理和布料图案分开设置，同理也可以将roughness和normal用一样的方式分开设置。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_cloth_basecol.png" alt="m_cloth_basecol"></li>
<li>blend angle corrected normal，这个内置函数可以混合两张法线贴图</li>
<li><strong>FuzzyShading</strong>，此函数可以使用于fuzz color，它支持我们控制菲涅尔</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_cloth_basecol.png" alt="m_cloth_basecol"></li>
<li>我们通过调节这些参数的组合得到不同的效果</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_cloth_display.png" alt="m_cloth_display"></li>
</ul>
<h3 id="🚩染色玻璃："><a href="#🚩染色玻璃：" class="headerlink" title="🚩染色玻璃："></a>🚩染色玻璃：</h3><p><strong>方案步骤：</strong></p>
<ol>
<li>使用顶点色，来打造有色玻璃的效果，并且玻璃的着色颜色仅显示在最厚的部分</li>
<li>使用UE中的内置函数，给玻璃表面添加磨砂或者模糊效果</li>
</ol>
<h4 id="🐢第一部分：创建基础玻璃"><a href="#🐢第一部分：创建基础玻璃" class="headerlink" title="🐢第一部分：创建基础玻璃"></a>🐢<strong>第一部分：创建基础玻璃</strong></h4><ul>
<li>创建material，使用blendMode为 Translucent，shading mode保持Default Lit。</li>
<li>随后去到Translucency的选项下，lighting Mode选择使用Surface ForwardShading或者Surface TranslucencyVolume，开启质量较高的着色选项。开启后可以发现material可以使用metallic，roughness等通道了。</li>
<li>设置一个简单的折射控制，使用fresnel作为Lerp，alpha来设置边缘到中心的折射参数。玻璃的IOR差不多设置在1.2-1.52之间。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_refraction.png" alt="m_glass_refraction"></li>
</ul>
<h4 id="🐢第二部分：加上玻璃边缘的磨砂绿色质感"><a href="#🐢第二部分：加上玻璃边缘的磨砂绿色质感" class="headerlink" title="🐢第二部分：加上玻璃边缘的磨砂绿色质感"></a>🐢<strong>第二部分：加上玻璃边缘的磨砂绿色质感</strong></h4><ul>
<li>这一部分使用Modes中的paint来绘制顶点色实现</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_vertexCol.png" alt="m_glass_vertexCol"></li>
<li>我们仅仅需要影响桌子的边缘，再将绘制好的顶点信息导入材质，以确定哪些区域被采用并进行上色。绘制完成后记得保存此vertex color到内容浏览器中。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_vertexColBlend.png" alt="m_glass_vertexColBlend"></li>
<li>添加使用vertex color</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_vertexColBlend2.png" alt="m_glass_vertexColBlend2"></li>
</ul>
<h4 id="🐢第三部分：使用菲涅尔改进色调真实度"><a href="#🐢第三部分：使用菲涅尔改进色调真实度" class="headerlink" title="🐢第三部分：使用菲涅尔改进色调真实度"></a>🐢<strong>第三部分：使用菲涅尔改进色调真实度</strong></h4><ul>
<li>使用Fresnel_Function，使玻璃内部和外部可以分开调节</li>
<li>使用Pixel NormalWS（像素法线世界空间）作为normal vector</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_Fresnel_Function2.png" alt="m_glass_Fresnel_Function2"></li>
<li>使用substract，设置玻璃的边缘透明度</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_edgeOpacity.png" alt="m_glass_edgeOpacity"></li>
<li>在视图窗口也可以使用Visual effect中的Planar Reflection来提升反射效果，得到更准确的反射（适用于平面，但不太适合其他有机形状）</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_table.png" alt="m_glass_table"></li>
</ul>
<h4 id="🐢第四部分：设置一些磨砂效果"><a href="#🐢第四部分：设置一些磨砂效果" class="headerlink" title="🐢第四部分：设置一些磨砂效果"></a>🐢<strong>第四部分：设置一些磨砂效果</strong></h4><ul>
<li>spiralBlur-SceneTexture，我们需要用这个自带函数来控制材质的自发光颜色，并需要与Opacity的边缘控制也关联</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_spirlblur.png" alt="m_glass_spirlblur"></li>
<li>现在我们需要反转之前绘制的vertex color再与spiralBlur相乘，来连接自发光颜色</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_spirlblur_emmisive.png" alt="m_glass_spirlblur_emmisive"></li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_glass_frosted.png" alt="m_glass_frosted"></li>
<li>切记多调整参数来得到满意的效果</li>
</ul>
<h3 id="🚩置换贴图，模拟毛毯地毯一类："><a href="#🚩置换贴图，模拟毛毯地毯一类：" class="headerlink" title="🚩置换贴图，模拟毛毯地毯一类："></a>🚩置换贴图，模拟毛毯地毯一类：</h3><blockquote>
<p><strong>发布支持DX11显卡时，引入了一项全新的硬件功能：real-time Dynamic Tessellation Geometry。使我们能够使用置换纹理贴图在显卡上增加对象的多边形面数，由此显著提升了对象的物理细节而无需真正对此细节进行建模。</strong></p>
</blockquote>
<ul>
<li>创建materail的时候，需要先开启细分。去Tessellation的选项下，D3D11Tesselation中选择Flat Tesselation。还要勾选Crack Free Displacement，保留Adaptive Tessellation。</li>
<li>此时Material中有新增了两个通道：<ul>
<li>World Displacement（用于连接displacement Map）</li>
<li>Tessellation Multiplier（控制有多少polygon总数添加到对象，数量越大，置换效果越详细，但一般不建议开的很高）</li>
</ul>
</li>
<li>一般情况下，displacement map使用普通灰度图即可。</li>
<li>如果在displacement的数值很高的情况下，导致边缘会产生与主体分离的效果，可以使用绘制vertex color来绘制边缘的部分，让边缘的部分不受tessellation的影响来解决这一问题。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20220917204344.png" alt="paintEdges"></li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_displacement.png" alt="m_displacement"></li>
<li>使用置换贴图必须先确保基础模型的网格数不会太低。</li>
<li>置换贴图也会对性能产生影响，所以要谨慎使用。</li>
</ul>
<h3 id="🚩顶点动画，创建窗帘随风吹动的效果："><a href="#🚩顶点动画，创建窗帘随风吹动的效果：" class="headerlink" title="🚩顶点动画，创建窗帘随风吹动的效果："></a>🚩顶点动画，创建窗帘随风吹动的效果：</h3><ul>
<li>了解“世界场景位置偏移”（World Position offset）</li>
<li>使用基本的material的设置创建布料材质作为基础，并使用World Position offset来创建窗帘的顶点动画</li>
<li>使用panner来加入动画，使用vertex color绘制需要动画的部分，并加入材质控制</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_vertexAni_graph1.png" alt="m_vertexAni_graph1"></li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_vertexAni_graph2.png" alt="m_vertexAni_graph2"></li>
<li>需要将这个模型对象设置为movable来获得正确的光照和阴影显示</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/m_vertexAni.png" alt="m_vertexAni"></li>
</ul>
<hr>
<p>终于刷完了！受益匪浅！</p>
]]></content>
      <categories>
        <category>-UE4</category>
      </categories>
      <tags>
        <tag>-材质</tag>
      </tags>
  </entry>
  <entry>
    <title>Light_a_Project_in_UE</title>
    <url>/2022/09/18/ue_Light_a_Project_in_UE/</url>
    <content><![CDATA[<p><strong>🍊这篇是UE的灯光与烘培的学习笔记，不大全面，有问题请随时指正🍊</strong><br>🍊这里是b站<a href="https://www.bilibili.com/video/BV17K4y1L7Gf/?spm_id_from=333.788.recommend_more_video.3&vd_source=95a1cfccd5b1e6779677de477b25aa31%5C">链接</a>🍊</p>
<hr>
<h1 id="Unreal-灯光照明与烘培"><a href="#Unreal-灯光照明与烘培" class="headerlink" title="Unreal 灯光照明与烘培"></a>Unreal 灯光照明与烘培</h1><h2 id="🚩【主要涵盖的话题】"><a href="#🚩【主要涵盖的话题】" class="headerlink" title="🚩【主要涵盖的话题】"></a>🚩【主要涵盖的话题】</h2><ol>
<li>技术和艺术的讨论</li>
<li>资产和场景的准备</li>
<li>灯光烘培设置</li>
<li>动态照明设置</li>
<li>图像基础的灯光设置</li>
<li>阴影</li>
<li>反射</li>
</ol>
<hr>
<h2 id="🚩【一：目标媒介】"><a href="#🚩【一：目标媒介】" class="headerlink" title="🚩【一：目标媒介】"></a>🚩【一：目标媒介】</h2><ul>
<li>考虑项目是否会定义到移动设备，或者是在一些需要高保真的媒体设备使用</li>
<li>每个镜头都是独立的视频项目的编辑方案</li>
<li>对于24FPS，30FPS和60FPS的项目的不同处理的方案</li>
<li>不需要完全实时渲染的项目</li>
<li>如果整个项目都是静态的，那么可以预先烘培</li>
<li>开放世界的灯光无法提前烘培，所以需要light map并使用动态照明处理</li>
<li>考虑硬件的最低规格</li>
</ul>
<hr>
<h2 id="🚩【二：Deferred-Renderer和Forward-Renderer】"><a href="#🚩【二：Deferred-Renderer和Forward-Renderer】" class="headerlink" title="🚩【二：Deferred Renderer和Forward Renderer】"></a>🚩【二：Deferred Renderer和Forward Renderer】</h2><h3 id="🥕Deferred-Renderer："><a href="#🥕Deferred-Renderer：" class="headerlink" title="🥕Deferred Renderer："></a>🥕Deferred Renderer：</h3><ul>
<li>是UE4的默认渲染器</li>
<li>它的工作方式就是储存所有原始数据在Screen Space Buffers（Color，Normal，Depth，…）然后将他们组合到一起成为Final Image</li>
<li>照明灯光一起评估</li>
<li>额外的screen space则会被用在更复杂的后处理效果与照明效果的组合</li>
<li>支持所有的渲染功能</li>
</ul>
<h3 id="🥕Forward-Renderer："><a href="#🥕Forward-Renderer：" class="headerlink" title="🥕Forward Renderer："></a>🥕Forward Renderer：</h3><ul>
<li>为了VR开发的</li>
<li>所有的lighting和shading都在object draw time进行评估计算</li>
<li>可以做特有的材质优化</li>
<li>更多的抗锯齿操作</li>
</ul>
<hr>
<h2 id="🚩【三：如何给一套好的照明准备资产】"><a href="#🚩【三：如何给一套好的照明准备资产】" class="headerlink" title="🚩【三：如何给一套好的照明准备资产】"></a>🚩【三：如何给一套好的照明准备资产】</h2><ol>
<li><strong>确保材质是物理正确的</strong><br> <img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/matRef.png" alt="matRef"><br>   常见问题有：<ul>
<li><ol>
<li>base color太亮或太暗。</li>
</ol>
</li>
<li><ol start="2">
<li>金属度为了确认是不是金属最好保持是1或0。</li>
</ol>
</li>
<li><ol start="3">
<li>specular保持0到1之间的灰度，而不是颜色。</li>
</ol>
</li>
<li><ol start="4">
<li>最黑的常见物是碳（rgb：0.03），最白的是雪（rgb：0.9）。永远不会是纯白或纯黑。</li>
</ol>
</li>
<li><ol start="5">
<li>vantablack是世界上最黑的黑（rgb：0.0045, roughness:1）</li>
</ol>
</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/vantablack.png" alt="vantablack"></li>
</ul>
</li>
<li><strong>打灯前确保移除自动曝光</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/deactiveAutoExposure.png" alt="deactiveAutoExposure"></li>
<li><strong>放置chrome sphere和grey sphere</strong><br> <img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/chromeSphere.png" alt="chromeSphere"><br> 保证它是纯反射物</li>
<li><strong>设置一个3.14（pi）的 directional light，并且用color picker 查看灰度</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/50%Grey.png" alt="50%Grey"></li>
</ol>
<hr>
<h2 id="🚩【四：烘培灯光-VS-动态灯光】"><a href="#🚩【四：烘培灯光-VS-动态灯光】" class="headerlink" title="🚩【四：烘培灯光 VS 动态灯光】"></a>🚩【四：烘培灯光 VS 动态灯光】</h2><h3 id="🥕Baked-Lighting："><a href="#🥕Baked-Lighting：" class="headerlink" title="🥕Baked Lighting："></a>🥕Baked Lighting：</h3><h4 id="🤓优势："><a href="#🤓优势：" class="headerlink" title="🤓优势："></a>🤓优势：</h4><ol>
<li>GI</li>
<li>cheap soft shadows，陈本低的阴影</li>
<li>Less GPU demanding，较低的GPU需求</li>
</ol>
<h4 id="😈劣势："><a href="#😈劣势：" class="headerlink" title="😈劣势："></a>😈劣势：</h4><ol>
<li>slower iteration，迭代变慢</li>
<li>static lighting，是静态的，如果生成更多的资产则新资产不会对照明产生影响</li>
<li>more maps in memory，需要储存空间来放light maps</li>
</ol>
<h3 id="🥕Dynamic-Lighting："><a href="#🥕Dynamic-Lighting：" class="headerlink" title="🥕Dynamic Lighting："></a>🥕Dynamic Lighting：</h3><h4 id="🤓优势：-1"><a href="#🤓优势：-1" class="headerlink" title="🤓优势："></a>🤓优势：</h4><ol>
<li>what u see is what u get，所见及所得</li>
<li>非静态的</li>
</ol>
<h4 id="😈劣势：-1"><a href="#😈劣势：-1" class="headerlink" title="😈劣势："></a>😈劣势：</h4><ol>
<li>No GI</li>
<li>GPU demanding，对GPU有要求</li>
</ol>
<hr>
<h2 id="🚩【五：常用烘培灯光设置】"><a href="#🚩【五：常用烘培灯光设置】" class="headerlink" title="🚩【五：常用烘培灯光设置】"></a>🚩【五：常用烘培灯光设置】</h2><h3 id="基础灯光设置："><a href="#基础灯光设置：" class="headerlink" title="基础灯光设置："></a>基础灯光设置：</h3><ol>
<li>Direction Light（Stationary）</li>
<li>Lightmass Baking（GI）</li>
<li>Skydome（static）</li>
</ol>
<h3 id="什么是light-map？"><a href="#什么是light-map？" class="headerlink" title="什么是light map？"></a>什么是light map？</h3><ul>
<li>light maps以纹理贴图的形式储存了灯光信息</li>
<li>它是HDR tecture并且储存了灯光方向</li>
<li>它的好处是处理起来很快，阴影柔和，但是如果文件太小则会缺少阴影的细节清晰度。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lightasset2.png" alt="lightasset2"></li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lightasset.png" alt="lightasset"></li>
<li>min lightmap resolution将定义UV islands（padding）之间的空间</li>
<li>更小的padding会减少像素的浪费以及在相同的分辨率下得到更好的阴影效果</li>
</ul>
<hr>
<h3 id="Lighting-Type："><a href="#Lighting-Type：" class="headerlink" title="Lighting Type："></a>Lighting Type：</h3><ul>
<li>当烘培灯光时，一般只会使用static light（静态光） 或者是 stationary light（固定光）</li>
<li>emit photons：<ul>
<li>Directional light</li>
<li>point light</li>
<li>spot light</li>
</ul>
</li>
<li>emit no photon：<ul>
<li>sky light</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Lightmass-Setting："><a href="#Lightmass-Setting：" class="headerlink" title="Lightmass Setting："></a>Lightmass Setting：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lightmass.png" alt="lightmass"></p>
<ul>
<li>static Lighting Level Scale * Indirect Lighting Quality &#x3D; 1.0;</li>
</ul>
<p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/lightmass_chart.png" alt="lightmass_chart"></p>
<ul>
<li>间接照明质量是最影响时长的</li>
</ul>
<hr>
<ul>
<li><strong>volume light sample scale</strong><ul>
<li>降低static lighting level scale会增加volume lighting samples的数量</li>
</ul>
</li>
<li><strong>lightmass Portal</strong><ul>
<li>对门窗类型的照明十分有用</li>
</ul>
</li>
<li><strong>lighting Scenarios</strong><ul>
<li>只用编辑一个enviroment level</li>
<li>照明方案会以light maps的形式分别储存</li>
<li>一个时间使用一个照明方案（不存在过渡，不能同时拥有两种在一个场景）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="🚩【六：常用动态照明设置】"><a href="#🚩【六：常用动态照明设置】" class="headerlink" title="🚩【六：常用动态照明设置】"></a>🚩【六：常用动态照明设置】</h2><h3 id="基础灯光设置：-1"><a href="#基础灯光设置：-1" class="headerlink" title="基础灯光设置："></a>基础灯光设置：</h3><ol>
<li>Direction Light（movable）</li>
<li>SKydome（moveable）</li>
<li>Distance Field AO</li>
<li>Screen Space AO</li>
</ol>
<h3 id="什么是Distance-Field："><a href="#什么是Distance-Field：" class="headerlink" title="什么是Distance Field："></a>什么是Distance Field：</h3><ul>
<li>Distance Field 储存了每个点到最近表面的距离</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/distanceField.png" alt="distanceField"></li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/df_setup.png" alt="df_setup"></li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/dfao.png" alt="dfao"></li>
<li>需要避免过多的缩放</li>
<li>很大的物体对于distance field 的支持不理想，需要拆分成较小的部分</li>
</ul>
<h2 id="🚩【七：图像基础的照明-IBL】"><a href="#🚩【七：图像基础的照明-IBL】" class="headerlink" title="🚩【七：图像基础的照明 IBL】"></a>🚩【七：图像基础的照明 IBL】</h2><h3 id="基础灯光设置：-2"><a href="#基础灯光设置：-2" class="headerlink" title="基础灯光设置："></a>基础灯光设置：</h3><ul>
<li>设置场景，确保有一个平面可以投射并接受阴影</li>
<li>有一个back plate（需要制作跟踪）（可以理解为UE里做nuke的事情）</li>
<li>Directional light（moveable）</li>
<li>Skylight with HDRI（moveable）</li>
<li>fake steps shadow</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/backPlate.png" alt="backPlate"></li>
<li>当人走向光照位置则激活阴影</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/IBL.png" alt="IBL"></li>
</ul>
<hr>
<h2 id="🚩【八：shadow-maps，for-Dynamic-Shadowing】"><a href="#🚩【八：shadow-maps，for-Dynamic-Shadowing】" class="headerlink" title="🚩【八：shadow maps，for Dynamic Shadowing】"></a>🚩【八：shadow maps，for Dynamic Shadowing】</h2><ul>
<li>Depth map，判断存在阴影的部分</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/depthMap.png" alt="depthMap"></li>
<li>如果shadow map质量太低会有锯齿</li>
<li>如果shadow map bias太高则会有漏光</li>
<li>使用相机视锥来优化场景，近景给予更多的资源</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/camFrustum.png" alt="camFrustum"></li>
</ul>
<hr>
<h2 id="🚩【九：Directional-Light-Stationary-area-shadows：】"><a href="#🚩【九：Directional-Light-Stationary-area-shadows：】" class="headerlink" title="🚩【九：Directional Light Stationary area shadows：】"></a>🚩【九：Directional Light Stationary area shadows：】</h2><ul>
<li>激活Lightmass下的：use Area Shadows for Stationary Light</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/areaShadow.png" alt="areaShadow"></li>
</ul>
<hr>
<h2 id="🚩【十：capsule-shadows：】"><a href="#🚩【十：capsule-shadows：】" class="headerlink" title="🚩【十：capsule shadows：】"></a>🚩【十：capsule shadows：】</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/capsuleshadows.png" alt="capsuleshadows"></p>
<ul>
<li>使用一个类似资产的外轮廓来创建一个十分柔和的阴影</li>
</ul>
<hr>
<h2 id="🚩【十一：Raytraced-contact-shadows：】"><a href="#🚩【十一：Raytraced-contact-shadows：】" class="headerlink" title="🚩【十一：Raytraced contact shadows：】"></a>🚩【十一：Raytraced contact shadows：】</h2><ul>
<li>将contact shadow length 设置的很小来获得细节上的阴影</li>
<li>在比例很小的物体上很有用，但是比较耗费资源</li>
</ul>
<hr>
<h2 id="🚩【十二：Reflections：】"><a href="#🚩【十二：Reflections：】" class="headerlink" title="🚩【十二：Reflections：】"></a>🚩【十二：Reflections：】</h2><ul>
<li>反射较为资源</li>
<li>使用planer reflection来得到平面的反射（本质是在镜像它），平面的物体适用，但此不适用于有机形状。</li>
</ul>
]]></content>
      <categories>
        <category>-UE4</category>
      </categories>
      <tags>
        <tag>-灯光</tag>
      </tags>
  </entry>
  <entry>
    <title>3Blue1Brown_线代本质第二章：线性组合，张成的空间与基</title>
    <url>/2022/09/22/math_Essense_of_Linear_Algebra_P02/</url>
    <content><![CDATA[<h1 id="3Blue1Brown-线代本质第二章：线性组合，张成的空间与基"><a href="#3Blue1Brown-线代本质第二章：线性组合，张成的空间与基" class="headerlink" title="3Blue1Brown_线代本质第二章：线性组合，张成的空间与基"></a>3Blue1Brown_线代本质第二章：线性组合，张成的空间与基</h1><ul>
<li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第二章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li>
<li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li>
<li>官方一共将此系列分为12节，所以我也会分开写。</li>
<li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li>
<li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li>
</ul>
<hr>
<h2 id="✏️基向量："><a href="#✏️基向量：" class="headerlink" title="✏️基向量："></a>✏️基向量：</h2><h3 id="✍️在xy坐标系中两个特殊向量："><a href="#✍️在xy坐标系中两个特殊向量：" class="headerlink" title="✍️在xy坐标系中两个特殊向量："></a>✍️在xy坐标系中两个特殊向量：</h3><ul>
<li>一个指向正右方，长度为1，通常被称为“i-hat”（i帽）或x方向的单位向量。</li>
<li>另一个指向正上方，长度为1，通常被称为“j-hat”（j帽）或者y方向的单位向量。</li>
<li><strong>i-hat与j-hat这两个向量有特殊的名称，他们是xy坐标轴的“基向量”（basis vector）。</strong></li>
<li>这是在表述：当你把坐标看为标量时，基向量实际上就是这些标量的缩放对象。</li>
</ul>
<hr>
<h3 id="✍️例子1："><a href="#✍️例子1：" class="headerlink" title="✍️例子1："></a>✍️例子1：</h3><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/ihat_jhat.png" alt="ihat_jhat"></p>
<ul>
<li><strong>由上图示意看出，（3，-2）可以想象为</strong>：x坐标是一个标量，它将i帽拉升为原来的三倍；y坐标也是一个标量，它将j帽反向并拉伸为原来的两倍。从这个角度看，这个向量实际上是两个经过缩放的向量的和。</li>
<li>“<strong>缩放向量并且相加</strong>”这一概念十分重要。</li>
</ul>
<hr>
<h3 id="✍️如果我们选择不同的基向量会怎么样："><a href="#✍️如果我们选择不同的基向量会怎么样：" class="headerlink" title="✍️如果我们选择不同的基向量会怎么样："></a>✍️如果我们选择不同的基向量会怎么样：</h3><ul>
<li><strong>我们完全可以选择不同的基向量，获得一个合理的新坐标系。</strong></li>
<li>比如随便选一个指向右上方的向量，再随便选择一个指向右下方的向量，想象通过选择两个标量，分别用于缩放二者的其中一个， 然后把他们相加，就可以得到不同的结果。通过改变所选择的向量，我们可以得到所有向量。</li>
<li>一对新的基向量，同样允许我们在一对数和二维向量之间自由转化。但是这种变化关系与我们之前使用的i帽和j帽的变化关系完全不同。</li>
<li><strong>每当我们用数字描述向量的时候，它都依赖于我们正在使用的基。</strong></li>
<li><strong>两个数乘向量的和被称为这两个向量的线性组合（Linear combination）。</strong></li>
<li><strong>那么线性怎么来的可以考虑为：</strong> 如果固定其中一个标量，让另一个标量自由变化，所产生的终点会描述出一条直线，如下图所示。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/linearCombination.png" alt="linearCombination"></li>
</ul>
<hr>
<ul>
<li><strong>如果让两个标量同时自由变换，考虑所有可得到的向量，可能有两种情况（实际是三种）：</strong><ol>
<li>大部分情况下，对于一对初始向量，你能达到平面中每一个点；所有二维向量都尽在掌握。</li>
<li>另一种较为糟糕的情况是，当两个初始向量恰好共线时，所产生的向量的终点被限制在一条过原点的直线上。</li>
<li>事实上还有第三种情况就是，两个向量都是零向量,那就只能在原点了。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%90%91%E9%87%8F%E5%8F%98%E6%8D%A2%E7%9A%84%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5.png" alt="向量变换的三种情况"></li>
</ol>
</li>
</ul>
<hr>
<h2 id="✏️张成空间（span）："><a href="#✏️张成空间（span）：" class="headerlink" title="✏️张成空间（span）："></a>✏️张成空间（span）：</h2><p><strong>概念：</strong><br>    - <strong>所有可以表示为给定向量线性组合的向量的集合，被成为给定向量张成的空间。</strong></p>
<ul>
<li>下图：向量全部线性组合构成的向量集合成为“张成的空间”，a与b在实数范围内变动。</li>
<li><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%BC%A0%E6%88%90%E7%A9%BA%E9%97%B4.png" alt="张成空间"></li>
</ul>
<h3 id="✍️二维空间内张成空间："><a href="#✍️二维空间内张成空间：" class="headerlink" title="✍️二维空间内张成空间："></a>✍️二维空间内张成空间：</h3><ul>
<li>通常情况下，我们用向量的终点代表向量（起点是原点）；用这种方法来看，如果要考虑落在一条直线上所有向量的时候，只需要考虑直线本身就行了。所以也可以考虑为，如果同时考虑xy坐标系中所有向量，将每个向量抽象为它的终点，实际上就不用考虑所有的肩头了，只需要考虑无限大的二维平面本身即可。</li>
<li>如果考虑一个向量，我们就可以把他看作箭头；如果考虑多个向量，则可以把他们都看作是点。</li>
<li>对大部分二维向量来说，它们的张成空间是整个无限大的二维平面；但如果共线，他们的张成空间就是一条直线。</li>
</ul>
<hr>
<h3 id="✍️三维空间内张成空间："><a href="#✍️三维空间内张成空间：" class="headerlink" title="✍️三维空间内张成空间："></a>✍️三维空间内张成空间：</h3><h4 id="在三维空间中取两个指向不同方向的向量，他们的张成空间是这样的："><a href="#在三维空间中取两个指向不同方向的向量，他们的张成空间是这样的：" class="headerlink" title="在三维空间中取两个指向不同方向的向量，他们的张成空间是这样的："></a>在三维空间中取两个指向不同方向的向量，他们的张成空间是这样的：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%B8%A4%E4%B8%AA%E5%90%91%E9%87%8F%E5%9C%A8%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4.png" alt="两个向量在三维空间"></p>
<ul>
<li>这两个向量的张成空间就是他们所有可能的线性组合；也就是缩放再相加之后所有可得到的向量。</li>
<li>逐渐改变线性组合中的这两个标量，把缩放后的向量相加，然后跟着最终向量的终点走，这个终点会画出三维空间中某个过原点的平面；这个平面就是这两个向量的张成空间。（所有终点落在这个平面上的向量集合是这两个向量的张成空间）</li>
</ul>
<h4 id="如果加上第三个向量，他们的张成空间是这样的："><a href="#如果加上第三个向量，他们的张成空间是这样的：" class="headerlink" title="如果加上第三个向量，他们的张成空间是这样的："></a>如果加上第三个向量，他们的张成空间是这样的：</h4><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E4%B8%89%E4%B8%AA%E5%90%91%E9%87%8F%E5%9C%A8%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4.png" alt="三个向量在三维空间"></p>
<ul>
<li>选择三个向量分别进行缩放，然后把结果相加。</li>
<li>这三个向量所有可能的线性作何构成了他们的张成空间。</li>
<li>如果第三个向量恰好落在前两个向量所张成的平面上，那么他们张成的空间并不改变，还是在这个平面中。</li>
<li>但是如果随机选一个向量，他几乎不可能落在前两个向量所张成的平面中；这种情况下，由于第三个向量指向不同的方向，我们就能得到所有的三维向量。（可以考虑成：当我们缩放第三个向量的时候，他将前两个向量张成平面来回沿着它的方向移动，从而扫过整个三维空间。）</li>
</ul>
<hr>
<h2 id="✏️Linearly-dependent-和-Linearly-Independent："><a href="#✏️Linearly-dependent-和-Linearly-Independent：" class="headerlink" title="✏️Linearly dependent 和 Linearly Independent："></a>✏️Linearly dependent 和 Linearly Independent：</h2><h4 id="当向量共线的情况，或第三个向量恰好落在之前向量生成的平面的情况下："><a href="#当向量共线的情况，或第三个向量恰好落在之前向量生成的平面的情况下：" class="headerlink" title="当向量共线的情况，或第三个向量恰好落在之前向量生成的平面的情况下："></a>当向量共线的情况，或第三个向量恰好落在之前向量生成的平面的情况下：</h4><ul>
<li>这种情况说明一组向量中至少有一个是多余的，没有对张成空间做出任何贡献，我们取走这个多余的向量也不减少张成空间，这样的情况下，我们称它为“<strong>线性相关</strong>”（<strong>Linearly dependent</strong>）的。</li>
</ul>
<h4 id="如果所有向量都给张成空间添加了新的维度："><a href="#如果所有向量都给张成空间添加了新的维度：" class="headerlink" title="如果所有向量都给张成空间添加了新的维度："></a>如果所有向量都给张成空间添加了新的维度：</h4><ul>
<li>这种情况就称之为“<strong>线性无关</strong>”（<strong>Linearly Independent</strong>）的。</li>
</ul>
<hr>
<h2 id="✏️基的严格定义（Technical-definition-of-basis）："><a href="#✏️基的严格定义（Technical-definition-of-basis）：" class="headerlink" title="✏️基的严格定义（Technical definition of basis）："></a>✏️基的严格定义（Technical definition of basis）：</h2><ul>
<li>The basis of a vector space is a set of linearly independent vectors that span the full space<br>(向量空间的一组基是张成该空间的一个线性无关向量集)<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%9F%BA%E7%9A%84%E4%B8%A5%E6%A0%BC%E5%AE%9A%E4%B9%89.png" alt="基的严格定义"></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>-3Blue1Brown线性代数本质</category>
      </categories>
      <tags>
        <tag>-学数学</tag>
      </tags>
  </entry>
  <entry>
    <title>这是一篇测试</title>
    <url>/2022/09/07/%E6%B5%8B%E8%AF%95%E4%B8%80/</url>
    <content><![CDATA[<p>这是一个测试，看看第一篇是否顺利保存并打开！<br>这里只是一个简陋的文本所以跳过就行</p>
]]></content>
  </entry>
  <entry>
    <title>UE4以及相关工具学习列表合辑</title>
    <url>/2022/09/09/unreal/</url>
    <content><![CDATA[<p>这篇是我的UE学习记录了，也算是我的UE学习置顶占位。2022是我学习UE的第一年，来记录一下<br>然后写的不一定是教程笔记哈，有些别的好的我也会随意写写放上来。<br>详细如下，都有各个的部分的站内链接<br>每篇写好了就会更新！<br>博客是新开的，整理上来需要时间，如果有兴趣讨论的朋友也可通过我主页的联系方式找我哈！</p>
<hr>
<h1 id="🚩UE材质基础"><a href="#🚩UE材质基础" class="headerlink" title="🚩UE材质基础"></a>🚩UE材质基础</h1><h2 id="一：UE4官方材质课-基础篇"><a href="#一：UE4官方材质课-基础篇" class="headerlink" title="一：UE4官方材质课_基础篇"></a>一：UE4官方材质课_基础篇</h2><p><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/uefoundation_cover.png" alt="uefoundation_cover"><br><strong>站内link：</strong></p>
<a href="/2022/09/13/ue_MatClass_foundation/" title="UE4官方材质课_基础篇">UE4官方材质课_基础篇</a>

<hr>
<h1 id="🚩UE灯光技巧："><a href="#🚩UE灯光技巧：" class="headerlink" title="🚩UE灯光技巧："></a>🚩UE灯光技巧：</h1><h2 id="一：UE灯光流程以及方案（Light-a-project-in-UE）"><a href="#一：UE灯光流程以及方案（Light-a-project-in-UE）" class="headerlink" title="一：UE灯光流程以及方案（Light a project in UE）"></a>一：UE灯光流程以及方案（Light a project in UE）</h2><p><strong>站内link：</strong></p>
<a href="/2022/09/18/ue_Light_a_Project_in_UE/" title="Light_a_Project_in_UE">Light_a_Project_in_UE</a>]]></content>
      <categories>
        <category>-UE4</category>
      </categories>
      <tags>
        <tag>-学习</tag>
      </tags>
  </entry>
  <entry>
    <title>3Blue1Brown_线代本质第三章：矩阵与线性变换</title>
    <url>/2022/09/24/math_Essense_of_Linear_Algebra_P03/</url>
    <content><![CDATA[<h1 id="3Blue1Brown-线代本质第三章：矩阵与线性变换"><a href="#3Blue1Brown-线代本质第三章：矩阵与线性变换" class="headerlink" title="3Blue1Brown_线代本质第三章：矩阵与线性变换"></a>3Blue1Brown_线代本质第三章：矩阵与线性变换</h1><ul>
<li>我开始了<strong>3蓝1棕</strong>的<strong>线性代数本质</strong>的学习，我没什么基础所以在此做了笔记，这里是第三章打卡，学习永远不怕晚哈！如有问题请各位大佬及时指正！</li>
<li>在b站它的<a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&vd_source=95a1cfccd5b1e6779677de477b25aa31">链接在此</a>。</li>
<li>官方一共将此系列分为12节，所以我也会分开写。</li>
<li>我会把相关的这一系列笔记链接在每一篇的最下面，写完就会更新，有需要的朋友可以自行跳转！</li>
<li>这就是普通的记录，比较基础，没什么有新意的地方。厉害的大佬或相关专业的大佬可以自行跳过此笔记！</li>
</ul>
<hr>
<h2 id="✏️线性变换："><a href="#✏️线性变换：" class="headerlink" title="✏️线性变换："></a>✏️线性变换：</h2><p>【<strong>注</strong>：这章节讨论在二维空间的样子，以及与矩阵向量乘法的关联，并展示一种不用死记硬背的考虑矩阵向量乘法的方法。】</p>
<h3 id="✍️解析“线性变换”："><a href="#✍️解析“线性变换”：" class="headerlink" title="✍️解析“线性变换”："></a>✍️解析“线性变换”：</h3><ul>
<li>Linear Transformation &#x3D; Linear Function</li>
<li>“变换”（Transformation）本质上是“函数”（function）的一种花哨的说法；它接受输入内容，并输出对应结果。</li>
<li>变换和函数意义相同还要用不同的词汇表达的原因是：使用“变换”是在暗示以特定的方式来可视化这一“输入”“输出”关系；“变换”这个词在按时我们用运动去思考。</li>
<li>每一个输入向量都移动到输出向量的位置：将向量看作是点，那么变换就是空间中的点移动到其他点的位置。</li>
<li><strong>直观的说，如果一个变换具有以下两条性质，我们就可以称它是线性的</strong>：<br>  <strong>1. 直线在变换后仍然保持为直线，不能有所弯曲。</strong><br>  <strong>2. 原点保持固定。</strong><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E8%A7%84%E5%88%99.png" alt="线性变换规则"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20220924214734.png" alt="20220924214734"></li>
<li><strong>总的来说，可以把线性变换看作是“保持网格线平行且等距分布”的变换</strong>。部分线性变换比较容易思考，如：网格以原点为轴心进行旋转；其他的则稍加复杂。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2.png" alt="线性变换"></li>
</ul>
<hr>
<h3 id="✍️如何用数值描述线性变换："><a href="#✍️如何用数值描述线性变换：" class="headerlink" title="✍️如何用数值描述线性变换："></a>✍️如何用数值描述线性变换：</h3><ul>
<li><p>我们给出一个向量坐标，希望得到一个变换后向量的坐标只需要通过：</p>
<ul>
<li><strong>记录两个基向量i帽和j帽变换后的位置，其他向量也会随之而动</strong></li>
</ul>
</li>
<li><p>由下图可视，向量v的坐标原本为（-1，2），这个向量可以看作为-1与i帽之积和2与j帽之基的和。如果运用一些变换，使得向量一起运动，并尊重“网格保持平行且等距分布”这个原则，变换后的向量v的位置，就是-1与变换后i帽之积加上2与变换后j帽之积。</p>
</li>
<li><p>换句话说，向量v是i帽和j帽的一个特定线性组合；那么变换后的向量v也是变换后i帽与j帽同样的线性组合。这就意味着，你可以只根据变换后的i帽与j帽，就推断出变化后的v。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E6%95%B0%E5%80%BC%E6%8F%8F%E8%BF%B0%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2.png" alt="数值描述线性变换"></p>
</li>
<li><p>一般情况下，一个向量的坐标是（x，y），变换后的向量就是x乘变换后的i帽，加上y乘变换后的j帽。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%85%AC%E5%BC%8Fpng.png" alt="公式png"></p>
</li>
<li><p>一个二维线性变换仅由四个数字完全确定：变换后i帽的两个坐标与变换后j帽的两个作坐标。</p>
</li>
<li><p>通常我们将这些坐标装在一个2x2的格子中，称它为2x2矩阵。</p>
</li>
</ul>
<hr>
<h2 id="✏️矩阵："><a href="#✏️矩阵：" class="headerlink" title="✏️矩阵："></a>✏️矩阵：</h2><ul>
<li>如果有一个描述线性变换的2x2矩阵，以及一个给定的初始向量，你只需要取初始向量的坐标，将他们分别于矩阵的特定列相乘，然后结果相加即可。这与“缩放基向量再相加”的思想一致。</li>
<li><strong>矩阵在这里只是一个记号，它含有描述线性变换的信息。</strong></li>
<li>如下图所示：我们可以把矩阵的第一列（a，c）看作是变换后第一个基向量，把第二列（b，d）看作是变换后第二个基向量；我们将这个变换作用于向量（x，y），它的结果就是（ax+by，cx+dy）。我们可以把它定义为<strong>矩阵向量乘法</strong>。<strong>矩阵放在向量左边，类似一个函数</strong>。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/2x2%E7%9F%A9%E9%98%B5%E5%85%AC%E5%BC%8F.png" alt="2x2矩阵公式"><br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E7%9F%A9%E9%98%B5%E5%90%91%E9%87%8F%E4%B9%98%E6%B3%95.png" alt="矩阵向量乘法"></li>
<li><strong>我们完全可以把矩阵的列看作变换后的基向量，把矩阵向量的乘法看作他们的线性组合。</strong></li>
<li>线性变换是操纵空间的一种手段；这种变换只需要几个数字就可以描述清楚，这些数字就是变换后的基向量的坐标。</li>
</ul>
<hr>
<h3 id="✍️示例：逆时针旋转90度"><a href="#✍️示例：逆时针旋转90度" class="headerlink" title="✍️示例：逆时针旋转90度"></a>✍️示例：逆时针旋转90度</h3><ul>
<li>如下图示例，i帽初始为（1，0），j帽初始为（0，1）；如果将他们逆时针旋转90度，那么变换后的i帽就是（0，-1），j帽就是（-1，0）。</li>
<li>如果此时我们想计算一个向量逆时针旋转90度：可以直接将这个向量（x，y）与变换后的i帽与j帽相乘。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/%E5%90%91%E9%87%8F%E9%80%86%E6%97%B6%E9%92%88%E6%97%8B%E8%BD%AC90%E5%BA%A6%E6%A1%88%E4%BE%8B.png" alt="向量逆时针旋转90度案例"></li>
</ul>
<hr>
<h3 id="✍️Shear（剪切-x2F-错切）："><a href="#✍️Shear（剪切-x2F-错切）：" class="headerlink" title="✍️Shear（剪切&#x2F;错切）："></a>✍️Shear（剪切&#x2F;错切）：</h3><ul>
<li>i帽保持为（1，0），j帽移动到坐标（1，1）。为了计算一个向量变换后的位置，可以直接将向量与这个矩阵相乘。<br><img src="https://ztcnntstop.oss-cn-shanghai.aliyuncs.com/20220925165136.png" alt="shear"></li>
</ul>
<hr>
<h3 id="✍️反向思考："><a href="#✍️反向思考：" class="headerlink" title="✍️反向思考："></a>✍️反向思考：</h3><ul>
<li>如果我们希望推测一个矩阵代表的线性变换是什么样的，我们可以将i帽与j帽先移动到变换后的位置，空间其他剩余部分则跟随二者一起运动，以保持网格线平行且等距分布。</li>
<li>如果变换后的i帽和变换后的j帽是线性相关的，意味着其中一个向量是另一个的倍数，那么这个线性变换将整个二维空间挤压到他们所在的一条直线上，也就是这儿两个线性相关向量所张成的一维空间。</li>
</ul>
<hr>
<h2 id="✏️总结："><a href="#✏️总结：" class="headerlink" title="✏️总结："></a>✏️总结：</h2><ul>
<li><strong>总之，线性变换是操纵空间的一种手段，它保持网格线平行且等距分布，并且保持原点不动。</strong></li>
<li>这种变换只需要几个数字就能够描述清楚，这些数字就是变换后基向量的坐标；以这些坐标为列所构成的矩阵为我们提供了一种描述线性变换的语言。矩阵向量乘法就是计算线性变换作用于给定向量的一种途径。</li>
<li>矩阵都可以理解为对空间的一种特定变换。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>-3Blue1Brown线性代数本质</category>
      </categories>
      <tags>
        <tag>-学数学</tag>
      </tags>
  </entry>
</search>
